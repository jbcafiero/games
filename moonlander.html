<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
<link href="https://fonts.googleapis.com/css?family=Orbitron|Questrial|Staatliches|ZCOOL+QingKe+HuangYou" rel="stylesheet">
    <!-- font-family: 'ZCOOL QingKe HuangYou', cursive;
        font-family: 'Staatliches', cursive;
        font-family: 'Questrial', sans-serif;
        font-family: 'Orbitron', sans-serif; -->
    <style media="screen">
      .statBarItem {
        font-family: 'Orbitron', sans-serif;
        font-size: 20px;
        color: white;
        transition: color 0.3s;
        float: left;
        margin: none;
        padding: none;
      }

      body {
        background: #1e1e1e;
        text-align: center;
      }

      .startButton {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        width: 33.3%;
        height: 85px;
        margin: 270px 33.3%;
        display: block;
        z-index: 50;
        font-family: 'Orbitron', sans-serif;
        font-size: 30px;
        color: white;
        background: none;
        border: 2px solid white;

        transition: background 0.15s, color 0.15s, padding 0.15s, margin 0.15s, opacity 0.6s;
      }
      .startButton:hover {
        color: black;
        background: white;
      }


      .tempBar {
        height: 20px;
        width: 150px;
        background-image: linear-gradient(to right, blue , red);
        float: left;

        margin-left: 10px;
        position: relative;
        border-radius: 2px;
      }

      #stats {
        margin-left: 15px;
        opacity: 0;
        left: 0;
        top: 0;
        transition: opacity 0.6s;
      }
      .breakUpStats {
        text-align: left;
        float: right;
        width: 250px;
      }
      #fuelBar {
        border-radius: 2px;
        position: absolute;
        height: 20px;
        width: 150px;
        background-color: white;
        z-index: 1;
      }

      #meterBar {
        position: absolute;
        left: 75px;
        height: 20px;
        width: 4px;
        background: yellow;
      }

      #backDropBar {
        border-radius: 2px;
        position: relative;
        float: left;
        z-index: -1;
        width: 150px;
        margin-top: 25px;
        margin-left: 10px;
        height: 20px;
        background: #424242;
      }

      .rightStatBars {
        height: 50px;
        font-family: 'Orbitron', sans-serif;
        font-size: 20px;
        color: white;
        width: 300px;
        transition: color 0.3s;
        float: right;
      }

      #leftBars {
        float: left;
        width: 350px;
        opacity: 1;
        transition: opacity 0.2s;
      }

      #healthBar {
        border-radius: 2px;
        position: absolute;
        height: 20px;
        width: 150px;
        background-color: green;
        z-index: 1;
      }

      .gameScreen {
        position: relative;
      }
      .titleBar {
        height: 500px;
        width: 1000px;
        test-align: center;
        position: absolute;
        left: 0;
        right: 0;
        margin: 250px auto;
        z-index: 200;
        opacity: 1;
        transition: opacity 0.6s;
      }

      #titleText {
        position: absolute;
        top: 0;
        opacity: 1;
        display: block;
        width: 95%;
        margin: -25px 2.5%;
        transition: opacity 0.6s;
      }

      .gameOverButton {
        position: absolute;
        z-index: 1000;
        font-family: 'Orbitron', sans-serif;
        font-size: 30px;
        color: red;
        background: none;
        padding: 20px 50px;
        border: 2px solid red;

        transition: background 0.15s, color 0.15s, padding 0.15s, margin 0.15s;
      }

      .gameOverButton:hover {
        color: black;
        padding: 22px 52px;
        background: red;
        margin-left: 1px;
      }

      .canvasBasic {
        padding: 0;
        background: none;
        position: absolute;
      }

      #usernameInput {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        width: 31.0%;
        padding: 1%;
        height: 50px;
        margin: 175px 33.3%;
        display: block;
        z-index: 1000;
        font-family: 'Orbitron', sans-serif;
        font-size: 30px;
        color: white;
        background: none;
        border: 2px solid white;

        transition: border 0.2s margin 0.2s;
      }
      #usernameInput:focus {
        margin: 171px 33.1%;
        border: 4px solid white;
      }

      .otherOptions {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        width: 33.3%;
        height: 85px;
        margin: 370px 33.3%;
        display: block;
        z-index: 50;
        font-family: 'Orbitron', sans-serif;
        font-size: 30px;
        color: white;
        background: none;

        transition: background 0.15s, color 0.15s, padding 0.15s, margin 0.15s, opacity 0.6s;
      }

      .options {
        position: absolute;
        z-index: 100px;
        float: left;
        background: none;
        height: 60%;
        width: 15%;
        border: 2px solid white;

        transition: background 0.15s, color 0.15s, padding 0.15s, margin 0.15s, opacity 0.6s;
      }

      .options:hover {
        background: white;
        color: black;
      }

    </style>
  </head>
  <body>
    <div class="gameScreen">
      <div class="titleBar" id="gameOptions" style="">
        <div id="titleText">
          <p id="titleInfo" style="font-size: 70px; font-family: 'Orbitron', sans-serif; color: white;">Terrestrial Traveler</p>
        </div>
        <input id="usernameInput" type="text" name="" value="" placeholder=" username">
        <button id="accsesStartButton" class="startButton" type="button" name="button" onclick="runFunc()">Play Game</button>
        <div class="otherOptions">
          <div class="options" id="info" style="margin-left: 0%;">
              <p type="button" style="font-family: 'Orbitron', sans-serif; font-size: 35px; margin-top: 5px;">i</p>
          </div>
          <div class="options" id="donate" style="margin-left: 42%">
            <p type="button" style="font-family: 'Orbitron', sans-serif; font-size: 35px; margin-top: 5px;">$</p>
          </div>
          <div class="options" id="leaderboard" style="margin-left: 84%">
            <p type="button" style="font-family: Helvetica; font-size: 70px; margin-top: -20px;">o</p>
          </div>
        </div>
      </div>
      <div id="stats" style="top: 0px; position: absolute; z-index: 2; height: 300px; width: 100%;">
        <div id="leftBars">
          <div class="breakUpStats" style="width: 250px;">
            <p class="statBarItem" id="fuel">Fuel: </p>
            <div id="backDropBar">
              <div id="fuelBar">
              </div>
            </div>
          </div>
          <div class="breakUpStats" style="width: 350px;">
            <p class="statBarItem" id="temp" style="margin: none; margin-top: -5px;">Temperature: </p>
            <div class="tempBar" style="position: relative;">
              <div id="meterBar">
              </div>
            </div>
          </div>
          <div class="breakUpStats" style="width: 275px; margin-top: -25px;">
            <p class="statBarItem" id="health">Health: </p>
            <div id="backDropBar">
              <div id="healthBar">
              </div>
            </div>
          </div>
        </div>

        <div class="breakUpStats">
          <p class="rightStatBars" id="dist">Distance: </p>
        </div>
      </div>
      <canvas id="canvas" class="canvasBasicWidths" width="1000" height="1000" style="background: black; position: absolute; z-index: -10;"></canvas>
      <canvas id="ball" class="canvasBasic canvasBasicWidths" width="1000" height="1000" style='z-index: -1;'></canvas>
      <canvas id="fire" class="canvasBasic canvasBasicWidths" width="1000" height="1000" style='z-index: -6;'></canvas>
      <canvas id="stars" class="canvasBasic canvasBasicWidths" width="1000" height="1000" style="z-index: -5;"></canvas>
      <canvas id="test" class="canvasBasic canvasBasicWidths" width="1000" height="1000" style="z-index: -4;"></canvas>
      <canvas id="particles" width="1000 canvasBasicWidths" height="1000" style="z-index: 1;"></canvas>
    </div>



  <script src="https://jeremyckahn.github.io/keydrown/dist/keydrown.min.js"></script>
  </body>
  <script type="text/javascript">
    var canv = document.getElementById("canvas");
    var ground = canv.getContext("2d");
    var tcanv = document.getElementById("test");
    var tester = tcanv.getContext("2d");
    var bcanv = document.getElementById('ball');
    var fcanv = document.getElementById('fire')
    var fire = fcanv.getContext('2d')
    var scanv = document.getElementById('stars')
    var star = scanv.getContext('2d')
    var pcanv = document.getElementById('particles')
    var particles = pcanv.getContext('2d')

    var manualCanvasArr = [canv, tcanv, bcanv, fcanv, scanv, pcanv];

    var gameOptions = document.getElementById("gameOptions");
    var startButton = document.getElementById("accsesStartButton");
    var fuel = document.getElementById("fuel");
    var temp = document.getElementById("temp");
    var dist = document.getElementById("dist");
    var statBar = document.getElementById("stats")
    var fuelMonitor = document.getElementById("fuelBar");
    var tempMonitor = document.getElementById("meterBar");
    var healthMonitor = document.getElementById("healthBar");
    var statLeft = document.getElementById("leftBars");
    var canvases = document.getElementsByClassName('canvasBasicWidths');
    var titleInformation = document.getElementById('titleInfo')

    var i;

    var titleScreenText = "Terrestrial Traveler"

    function drawStats(f, t, d, h) {
      var widthOfFuelBar = Math.floor(150 * (f/10000));
      var tempMonPos = Math.floor(150*t/200)-2;
      fuelMonitor.style.width = widthOfFuelBar.toString()+"px";
      tempMonitor.style.left = tempMonPos.toString()+"px";
      healthMonitor.style.width = h.toString()+"px";
      tempMonitor.style.width = "4px";
      tempMonitor.style.background = "yellow";

      dist.innerHTML = "Distance: " + d + "m";
      statBar.style.opacity = 1;
    }

    function drawTitleScreen() {
      gameOptions.style.opacity = "0";
      gameOptions.style.zIndex = -1000;
    }



    var test = [];
    var starPos = [];
    var landPositions = [];
    var enemyPositions = [];
    var blockSize = 1000/50;
    var variation = 10;
    var offset = 300;
    var lineBase = canv.height/2 + offset;
    var numberOfBlocks = 0;
    var windowWidth = window.innerWidth;
    var blockAmount = Math.ceil(windowWidth/blockSize)
    var canvasWidths = (blockSize*blockAmount) - (blockSize*3)

    var hillSize4 = 64;
    var hillSize = 32;
    var hillSize2 = 24;
    var hillSize3 = 16;

    var ticker = 1;
    var starTicker = 1;

    var plataue1 = 3;
    var plataueUsed = false;

    var requiredPadSize = 1;

    var scroll = 0;

    var playerDead = false;

    var platauePosition = Math.floor((Math.random() * blockAmount)+1-plataue1)

    function constructMountais(hillLength, varry, constant) {
      var change1 = Math.floor((Math.random() * 3)-2)
      var change2 = Math.floor((Math.random() * 3)-2)
      var change3 = Math.floor((Math.random() * 3)-2)
      for (var h = 0; h < hillLength; h++) {
        var hillRandom = Math.floor((Math.random() * constant)+varry)
        var chanceOfFlaw = Math.floor((Math.random() * 10)+1)
        var chanceOfLandingSpot = Math.floor((Math.random() * 25)+1)
        var flawRandom = Math.floor((Math.random() * (variation/2))+1-(variation/2)/2)
        plataue1 = Math.floor((Math.random() * 3)+4);
        var p = 0;

        if (chanceOfLandingSpot == 1) {
          plataueUsed = true;
          for (p = 0; p < plataue1; p++) {
            test[x+h+p] = test[x+h+p-1];
          }
        }

        if (h<=((hillLength/4)-1)-change1 && h>=0) {
          if (chanceOfFlaw == 4) {
            test[x+h+p] = test[x+h+p-1] + flawRandom;
          }
          else {
            test[x+h+p] = test[x+h+p-1] + hillRandom*0.5
          }
        }
        else if (h<=((hillLength/2)-1)-change2 && h>=(hillLength/4)-change1) {
          if (chanceOfFlaw == 4) {
            test[x+h+p] = test[x+h+p-1] + flawRandom;
          }
          else {
            test[x+h+p] = test[x+h+p-1] + hillRandom*1
          }
        }
        else if (h<=((hillLength*75)-1)-change3 && h>=(hillLength/2)-change2) {
          if (chanceOfFlaw == 4) {
            test[x+h+p] = test[x+h+p-1] + flawRandom;
          }
          else {
            test[x+h+p] = test[x+h+p-1] - hillRandom*1
          }
        }
        else if (h<=((hillLength)-1) && h>=(hillLength*75)-change3) {
          if (chanceOfFlaw == 4) {
            test[x+h+p] = test[x+h+p-1] + flawRandom;
          }
          else {
            test[x+h+p] = test[x+h+p-1] - hillRandom*0.5
          }
        }
        if (test[x]>=canv.height) {
          test[x] = canv.height - 10;
        }
        if (h >= hillLength-1) {
          x = x+h+p
        }
      }
    }

    function generateArrays() {
      for (var b = -40; b < 10000+41; b++) {
        starPos[b] = Math.floor((Math.random() * (scanv.height-(lineBase*0.3)))+1);
      }
      for (var b = -40; b < 10000+41; b++) {
        // creates the positions for enemies and possibly other featurs
        var decider = Math.floor((Math.random() * 300)+1)
        if (decider == 200) {
          enemyPositions[b] == 1
        }
        else {
          enemyPositions[b] == 0
        }
      }

  //////////////// For START For START For START For START For START For START For START For START For START
      for (x=-100; x<blockAmount + 101 + 10000;x++) {

        var basicRandom = Math.floor((Math.random() * variation)+1-variation/2)

        var proceduralChooser = Math.floor((Math.random() * 4)+1)

        switch (proceduralChooser) {
          case 1:
            constructMountais(hillSize, 20, 15);
          break;
          case 2:
            constructMountais(hillSize2, 10, 10);
          break;
          case 3:
            constructMountais(hillSize3, 13, 13);
          break;
          case 4:
            constructMountais(hillSize4, 16, 16);
          break;
          default:
            if (test[x-1] != undefined) {
              test[x] = test[x-1] + basicRandom
            }
            else {
              test[x] = basicRandom+35;
            }
          break;
        }
        test[x] = basicRandom+35;
      }

      for (var n = 0; n < test.length; n++) {

        if (test[n] > lineBase-60 || test[n] < lineBase-950) {
          var e = n
          while (test[e] > lineBase-60) {
            test[e] = lineBase-60;
            e++
          }
          while (test[e] < lineBase-950) {
            test[e] = lineBase-950
            e++
          }
        }

        var slopeDifference;
        var startToEnd = 0;
        slopeDifference = test[n] - test[n+1];
        landPositions[n] = 0;
        // This just polishes the terrain. putting in as extra bit, but does not work as apart of the rest of the algorithm
        if (slopeDifference > 50 || slopeDifference < -50) {
          test[n+1] = test[n+1]/6;
        }
        while (slopeDifference < 3 && slopeDifference > -3) {
          n = n + 1;
          landPositions[n] = 0;
          startToEnd = startToEnd + 1;
          slopeDifference = test[n] - test[n+1];
          if (slopeDifference > 50 || slopeDifference < -50) {
            test[n+1] = test[n+1]/6;
          }
        }
        if (startToEnd > requiredPadSize) {
          var tempValueHold = n;
          var amountOfStepsIn = 0;
          //n will have startToEnd taken from it
          //this will avoid a endless loop beacause if n
          //is overly manipulated, it could cause endless loop
          for (var n = n - startToEnd+1; n <= tempValueHold; n++) {
            amountOfStepsIn = amountOfStepsIn + 1;
            // test[n] = test[n-amountOfStepsIn] + Math.floor((Math.random() * 3)-1); //levels any area within the for loop
            landPositions[n] = 1;
          }
        }
      }
    }



    ///For END For END For END For END For END For END For END For END For END
    function drawStars(x, cy) {
      if (i==0+starTicker-1) {
        scanv.width = canvasWidths;
        star.translate(0-scroll/2, 0);
      }
      // star.arc(x, y, 2, 0, 2 * Math.PI);
      star.beginPath();
      star.moveTo(x, cy);
      star.lineTo(x+2, cy-2);
      star.lineTo(x, cy-4);
      star.lineTo(x-2, cy-2);
      star.closePath();
      star.fillStyle = "white";
      starAcceptable(x, cy)

    }

    var executeFill = false;

    function createLineBlock(starty, endy, color) {

      if (i==0+ticker-1) {
        canv.width = canvasWidths;
        ground.translate(0-scroll, 0)
      }
      ground.beginPath();
      ground.moveTo(blockSize * (i-1), starty);
      ground.lineTo(blockSize * (i), endy);
      ground.strokeStyle = color
      ground.stroke();

    }

    var ballRot = 60;
    var ballVelX = 0.7;
    var xMult;
    var yMult;
    var playerPositionX = canvasWidths/2;
    var groundHeight;
    var zoneCount = 0;
    var currentSlope;
    var yIntercept;
    var difference;
    var addStep;
    var finalAddStep;
    var zoneCountLeft;
    var zoneCountRight;

    //uses the numbers that created the visual line to create a tangable y position of the ground based on player's x position
    function drawTest() {
      var trueTick = ticker - 1;
      var scrollOffset = scroll - blockSize*(trueTick);
      zoneCount = Math.trunc((playerPositionX+scroll)/blockSize);
      zoneCountLeft = Math.trunc((-10+playerPositionX+scroll)/blockSize);
      zoneCountRight = Math.trunc((10+playerPositionX+scroll)/blockSize);


      if (i == 0+ticker-1) {
        groundHeight = lineBase - test[trueTick];
        difference = test[trueTick] - test[zoneCount + 1]
      }

      difference = test[zoneCount] - test[zoneCount + 1]
      addStep = Math.ceil((((playerPositionX+scroll)-(zoneCount*blockSize))/blockSize)*100)/100
      // addStep = Math.ceil((Math.trunc(playerPositionX+scroll/blockSize) - (playerPositionX+scroll/blockSize))*100)/100;
      finalAddStep = -(difference * addStep)
      groundHeight = lineBase - (test[zoneCount] + finalAddStep);
      // +(scroll-(blockSize*(ticker-1)))
    }
    function starAcceptable(x, sy) {
      var trueTick = starTicker - 1;
      var realScroll = scroll/2
      var scrollOffset = realScroll - blockSize*(trueTick);
      var zoneCount1 = Math.trunc((x+realScroll)/blockSize);
      var difference1;
      var addStep1;
      var finalAddStep1;

      if (i == 0+starTicker-1) {
        y = lineBase - test[trueTick];
        difference1 = test[trueTick] - test[zoneCount1 + 1]
      }

      difference1 = test[zoneCount1] - test[zoneCount1 + 1]
      addStep1 = Math.ceil((((x+realScroll)-(zoneCount1*blockSize))/blockSize)*100)/100
      // addStep = Math.ceil((Math.trunc(playerPositionX+scroll/blockSize) - (playerPositionX+scroll/blockSize))*100)/100;
      finalAddStep1 = -(difference1 * addStep1)
      y = lineBase - (test[zoneCount1] + finalAddStep1);
      // +(scroll-(blockSize*(ticker-1)))\
      if (sy < y+1) {
        star.fill();
      }
    }

    function renderGround() {
      var binarySwitch = 0;
      var timeDelayCounter = 0;
      var colorSwitch = "white";
      function updateGround() {
        // \/\/\/ creates blinking effect
          if (binarySwitch == 0) {
            timeDelayCounter++
            if (timeDelayCounter >= 20) {
              colorSwitch = "#4c4c4c"//#72ff7e just in case color
              binarySwitch = 1;
              timeDelayCounter = 0;
            }
          }
          else if (binarySwitch == 1){
            timeDelayCounter++
            if (timeDelayCounter >= 20) {
              colorSwitch = "white"
              binarySwitch = 0;
              timeDelayCounter = 0;
            }
          }
          // /\/\/\
        for(i=0+ticker-1; i<=blockAmount+ticker;++i) {

            if (landPositions[i] == 1) {
              createLineBlock(lineBase - test[i-1], lineBase - test[i], colorSwitch) //light green
            }
            else if(landPositions[i] == 0) {
              createLineBlock(lineBase - test[i-1], lineBase - test[i], "white")
            }
            else {
              createLineBlock(lineBase - test[i-1], lineBase - test[i], "white")
            }
          }

        for(i=0+starTicker-1; i<=blockAmount+starTicker;++i) {
          drawStars(i * blockSize, starPos[i]);
        }

        //Window Expansion
        windowWidth = window.innerWidth;
        if (windowWidth >= 1000) {
          blockAmount = Math.ceil(windowWidth/blockSize)
          canvasWidths = (blockSize*blockAmount) - (blockSize*3);
        }


      }
      var groundUpdateInit = setInterval(updateGround, 10);
    }

/////// Paricles Function
    var particleIndex = [];

    function animateParticles(color) {
      var playerXVelHold = ballVelX;
      var playerYVelHold = ballVel;
      for (var p = 0; p < 100; p++) {
        particleIndex[p] = {'curX':playerPositionX, 'curY':playerPositionY, 'velX':((Math.random() * 10)-5), 'velY':((Math.random() * 10)-5)}

        particleIndex[p].velY = (particleIndex[p].velY + ballVel)*-1;
      }
      var counterDowner = 0;
      var dampener = 0.99
      var sizeDecreaseer = 2.5;
      var fader = 1;
      function executeAnimation() {
        pcanv.width = canvasWidths;
        counterDowner++
        if (counterDowner > 250) {
          pcanv.width = canvasWidths;
          clearInterval(executerOfAnim);
        }
        if (sizeDecreaseer > 0) {
          sizeDecreaseer = sizeDecreaseer - 0.06;
        }
        else {
          sizeDecreaseer = 0;
        }
        if (fader > 0) {
          fader = fader - 0.08;
        }
        if (dampener < 1) {
          dampener = dampener - 0.0005;
        }
        for (var p = 0; p < 100; p++) {

          particleIndex[p].velX = particleIndex[p].velX * dampener
          particleIndex[p].velY = particleIndex[p].velY * dampener
          particleIndex[p].curX = particleIndex[p].curX + particleIndex[p].velX;
          particleIndex[p].curY = particleIndex[p].curY + particleIndex[p].velY;
          particles.rect(particleIndex[p].curX, particleIndex[p].curY, sizeDecreaseer, sizeDecreaseer);
          particles.fillStyle = color;
          fire.globalAlpha = 1;
          particles.fill();
        }
      }
      var executerOfAnim = setInterval(executeAnimation, 10);
    }

var ball = bcanv.getContext("2d");
var playerPositionY = 100;
var ballVel = 0;
var input = false;

function drawCircle(x, y, rot, color) {
  bcanv.width = canvasWidths;
  ball.translate(x, y);
  ball.rotate(ballRot * Math.PI / 180)
  ball.beginPath();
  ball.moveTo(0, -40);
  ball.lineTo(-15, -20);
  ball.lineTo(15, -20);
  ball.closePath();
  ball.moveTo(-15, 20);
  ball.lineTo(-15, 30);
  ball.lineTo(-5, 20);
  ball.closePath();
  ball.moveTo(15, 20);
  ball.lineTo(15, 30);
  ball.lineTo(5, 20);
  ball.closePath();
  // ball.rect(-2.5, 20.1, 5, 10)
  ball.rect(-15, -20, 30, 40);
  ball.fillStyle = color;
  ball.fill();
}

// function drawFire(x, y, otherx, othery) {
//   fcanv.width = fcanv.width;
//   fire.rotate(ballRot * Math.PI / 180)
//   fire.rect(x-7, y, 10, 10)
//   fire.rect(otherx-6, othery, 10, 10)
//   fire.fillStyle = "#e2320b";
//   fire.globalAlpha = fade;
//
//   fire.fill();
// }

  var gameStarted = 5;
  var fireParticlesX;
  var fireParticlesY;
  var canUseFire = true;

function fireMove(col) {

  var exhaust = []
  for (var z = 0; z < 60; z++) {
    exhaust[z] = {'posX':playerPositionX, 'posY':playerPositionY, 'velX':(-ballVelX), 'velY':0.0013, 'fade':1, 'col':`rgb(${255}, ${0}, ${0})`, 'redVal': 255, 'nonRed':0, 'reset':true};
  }
  var fakeLoop = 0
  var timeOffsetter = 0

  function moveTheFire() {////// CREATES THE FIRE PARTICLES

    if (gameStarted == 1 || input == true || fuelTrack < 2 || tempTrack > 198.5 || playerDead == true) {
      if (exhaust[fakeLoop].reset == true && input == true || exhaust[fakeLoop].reset == true && gameStarted == 1) {
        var randomManipulator = Math.random(1);
        var randomManipulatorX = (Math.random(3)-1)/6;
        var moreRandomness = Math.random(3);
        var evenMoreRandomness = Math.random(3);
        var direction = 0;
        var xVelocity = 0.9
        xVelocity = -1*(xVelocity*(ballRot/90))
        if (ballRot>=0) {
          var yAdd = ((90-ballRot)/4);
          var xAdd = ((90-ballRot)/3)-30;
          direction = -1;

        }
        else if (ballRot<0) {
          var yAdd = ((90-(-1*ballRot))/4);
          var xAdd = -(((90-(-1*ballRot))/3)-30);
          direction = 1;
        }
        if (gameStarted == 1) {
          exhaust[fakeLoop] = {'posX':playerPositionX+xAdd+evenMoreRandomness, 'posY':playerPositionY+yAdd+moreRandomness, 'velX':(-ballVelX)+randomManipulatorX, 'velY':0.17+randomManipulator, 'fade':1, 'col':`rgb(${255}, ${0}, ${0})`, 'exponential': 0.03, 'nonRed':0, 'reset':false};
        }
        else {
          exhaust[fakeLoop] = {'posX':playerPositionX+xAdd+evenMoreRandomness, 'posY':playerPositionY+yAdd+moreRandomness, 'velX':((xVelocity)+randomManipulatorX), 'velY':0.1+randomManipulator+fireParticlesY, 'fade':1, 'col':`rgb(${255}, ${0}, ${0})`, 'exponential': 0.03, 'nonRed':0, 'reset':false};

        }

      }
    }

    fcanv.width = canvasWidths;
    var completeAllParticlesFall = 0;
    for (var z = 0; z < 60; z++) {

      if (exhaust[z].reset == false) {
        exhaust[z].posX = exhaust[z].posX + exhaust[z].velX;
        if (exhaust[z].posY>groundHeight-3) {
          exhaust[z].velY = -1.03*exhaust[z].velY;
          exhaust[z].velX = (Math.random() * 3)-1;
        }
        exhaust[z].posY = exhaust[z].posY + exhaust[z].velY;
        exhaust[z].exponential = exhaust[z].exponential - 0.0003
        if (exhaust[z].exponential<0.005) {
          exhaust[z].exponential = 0.005;
        }
        exhaust[z].fade = exhaust[z].fade - exhaust[z].exponential;
        fire.rect(exhaust[z].posX, exhaust[z].posY, 4.5, 4.5)
        var trueFade = exhaust[z].fade
        fire.fillStyle = `rgb(${255}, ${(255*(1-trueFade))/2}, ${0})`;
        fire.globalAlpha = trueFade;
        fire.closePath();
        fire.fill();
      }
      if(exhaust[z].fade<0.01) {
        exhaust[z].reset = true;
        if (gameStarted!=1) {
          completeAllParticlesFall++
      }
        if (completeAllParticlesFall>=60) {
          gameStarted = 4;
        }
      }
    }


    fakeLoop++;

    if (fakeLoop>=60) {
      fakeLoop = 0;
    }

    if (gameStarted != 2) {
      if (gameStarted == 1 && gameStarted != 3) {
        if (scroll>=blockSize*ticker) {
          ticker = ticker + 1;
        }
        if ((scroll/2)>=blockSize*starTicker) {
          starTicker = starTicker + 1;
        }
        scroll = scroll + ballVelX;
      }
    }

    if (input == false && gameStarted == 4 || gameStarted == 2 || playerDead == true ) {
      clearInterval(moveInitiate);
      gameStarted = 3;
      fcanv.width = canvasWidths;
      canUseFire = true;
    }
  }
  var moveInitiate = setInterval(moveTheFire, 10)
}

document.addEventListener("DOMContentLoaded", function() {
  if (gameStarted == 5) {
    generateArrays();
    gameStarted = 1;
    for (var m = 0; m < manualCanvasArr.length; m++) {
      manualCanvasArr[m].width = canvasWidths;
    }
    fireMove("yellow")
    drawCircle(playerPositionX, playerPositionY, ballRot, spaceShipColor);
    renderGround();

  }

});

function shipColorAnim() {

  var hueShifter = 255;
  var shiftBack = false;
  delayerForColor = 0;
  function executHueShift() {
    if (hueShifter > 1 && shiftBack == false) {
      if (hueShifter>1) {
        hueShifter = hueShifter - 51;
      }
      if (hueShifter < 1) {
        hueShifter = 0;
      }
      if (hueShifter <= 1) {
        shiftBack = true;
      }
    }
    if (hueShifter == 0) {
      delayerForColor++
    }
    if (hueShifter < 255 && delayerForColor > 10) {
      hueShifter = hueShifter + 5;
      if (hueShifter >=255) {
        hueShifter = 255;
      }
    }
    spaceShipColor = `rgb(${255}, ${hueShifter}, ${hueShifter})`;
    if (hueShifter >= 255 && shiftBack == true) {
      clearInterval(terminationPower);
    }
  }
  var terminationPower = setInterval(executHueShift, 20);
}

var spaceShipColor = `white`;

drawCircle(playerPositionX, playerPositionY, ballRot, spaceShipColor);

var gravityMult = 0.0013
var contactMade = false;
var fuelTrack = 10000;
var healthTrack = 150;
var tempTrack = 100;
var distTrack = 0;
var beginningDist = 0;
var toggleExplosion = true;

var starty = playerPositionY;
var startx = playerPositionX;

function ballGravity() {
  var curvedCoolApply = 0;
  var curvedHeatApply = 0;
  var delayAction = 0
  function ballMult() {
      delayAction++
      drawTest(); // Draws procedural ground "mesh" and allows player to interect with ground
      ballVel = ballVel + gravityMult;

      if (playerPositionX>=canv.width*0.75) {
        playerPositionX = playerPositionX - ballVelX;
        scroll = scroll + ballVelX;
      }
      if (scroll>=blockSize*ticker) {
        ticker = ticker + 1;
      }
      if ((scroll/2)>=blockSize*starTicker) {
        starTicker = starTicker + 1;
      }

      ///// TRUE INPUT

    if (input == true && fuelTrack > 0 && tempTrack < 200 && delayAction>3) {
      if (canUseFire == true) {
        fireMove("red");
        canUseFire = false;
      }
      if (curvedHeatApply < 0) {
        curvedHeatApply = curvedHeatApply + 0.003;
      }
      fuelTrack = fuelTrack - 1;
      curvedCoolApply = 0;
      curvedHeatApply = curvedHeatApply + 0.00006;
      tempTrack = tempTrack + curvedHeatApply;

      fireParticlesY = (0.0035*yMult);
      fireParticlesX = (0.0035*xMult);
      ballVel = ballVel - (0.0035*yMult);
      ballVelX = ballVelX - (0.0035*xMult);
    }


    //// FALSE INPUT

    if (input == false) {
      if (contactMade == false && tempTrack > 50) {
        if (curvedHeatApply > 0) {
          curvedHeatApply = curvedHeatApply - 0.003;
        }
        curvedCoolApply = curvedCoolApply - 0.00003;
        tempTrack = tempTrack + curvedCoolApply;
      }
      fade = 0;
    }
    var velHolder = 0;
    if (playerPositionY >= groundHeight - 30.1) {
      velHolder = ballVel;
      ballVel = -ballVel * 0.25
      playerPositionY = groundHeight - 30.1;
    }
///
    if (playerPositionY >= groundHeight - 30.1 && playerPositionY <= groundHeight - 30.001) {

      if (ballVelX > 0) {
        ballVelX = ballVelX - 0.02;
      }
      else if (ballVelX < 0) {
        ballVelX = ballVelX + 0.02;
      }

      contactMade = true;
      if (contactMade == true && ballRot > 4 || contactMade == true && ballRot < -4 || contactMade == true && velHolder > 0.55 || contactMade == true && landPositions[zoneCount+1] == 0 || contactMade == true && landPositions[zoneCountLeft+1] == 0 || contactMade == true && landPositions[zoneCountRight+1] == 0) {
        playerDead = true;
        fuelTrack = 0;
        tempTrack = 0;
        healthTrack = 0;
      }
      else if (contactMade == true && velHolder > 0.32) {
        healthTrack = healthTrack - Math.floor((10*velHolder)*4);
        shipColorAnim(spaceShipColor);
        if (healthTrack<=0) {
          playerDead = true;
          fuelTrack = 0;
          tempTrack = 0;
          healthTrack == 0
          drawStats(fuelTrack, tempHolder, distTrack, healthTrack);
        }
      }

    }
    else if(playerPositionY <= groundHeight - 31) {
      contactMade = false;
    }
///
    //// Rot Inputs
    if (inputRotLeft == true && contactMade == false) {
      if (ballRot > -90) {
        ballRot--
      }
    }
    if (inputRotRight == true && contactMade == false) {
      if (ballRot < 90) {
        ballRot++
      }
    }

    if (contactMade == true) {
      if (tempTrack > 50) {
        curvedCoolApply = curvedCoolApply - 0.00015;
        tempTrack = tempTrack + curvedCoolApply;
      }
      else {
        curvedCoolApply = 0;
        tempTrack = tempTrack - 0.0003
      }
    }

    // Math that moves the player at different x and y velocities that makes sense with the rotation
    if (ballRot > 0) {
      if (ballRot < 45) {
        yMult = 1 - ballRot/90
        xMult = -(ballRot/90)
      }
      // more extreme rotation
      else if (ballRot > 45) {
        yMult = 1 - ballRot/90
        xMult = -(ballRot/90)
      }
    }
    else if (ballRot < 0) {
      if (ballRot >= -45) {
        yMult = 1 + ballRot/90
        xMult = (1 + ballRot/90)
      }
      //more extreme rotation
      else if (ballRot < -45) {
        yMult = 1 + ballRot/90
        xMult = -(ballRot/90)
      }
    }
    else {
      yMult = 1
      xMult = 0
    }
    // Air resistence
    if (ballVelX > 0) {
      ballVelX = ballVelX - 0.00003
    }
    else if (ballVelX < 0) {
      ballVelX = ballVelX + 0.00003
    }

    if (beginningDist < canv.width*0.75) {
      if (ballVelX > 0.01 && contactMade == false) {
        beginningDist = beginningDist + ballVelX;
        distTrack = beginningDist;
      }
    }
    else {
      if (ballVelX > 0.01 && contactMade == false) {
        beginningDist = canv.width*0.75 + 1;
        distTrack = beginningDist + scroll - scrollOffsetTitleScreen;
      }
    }

    //Constraints on going backwords
    if (playerPositionX < 20 && ballVelX < 0) {
      ballVelX = ballVelX/10
    }
    // makes stats see through when player goes near
    if (playerPositionX < 370 && playerPositionY < 165) {
      statLeft.style.opacity = 0.6;
    }
    else {
      statLeft.style.opacity = 1;
    }

    distTrack = Math.ceil(distTrack*100)/100
    var tempHolder = Math.ceil(tempTrack*100)/100
    drawStats(fuelTrack, tempHolder, distTrack, healthTrack);
    if (playerDead == false) {
      drawCircle(playerPositionX, playerPositionY, ballRot, spaceShipColor)
    }
    else if (playerDead == true) {
      bcanv.width = canvasWidths;
      gameOptions.style.opacity = "1";
      gameOptions.style.color = "red";
      gameOptions.style.zIndex = 700;
      startButton.innerHTML = "Play Again"
      titleInformation.style.color = "red";
      titleInformation.innerHTML = "Game Over";
      if (toggleExplosion == true) {
        animateParticles("white")
        toggleExplosion = false;
      }

      // startButton.style.zIndex = 1000;
      // startButton.classList.replace("startButton", "gameOverButton")
      // startButton.innerHTML = "Play Again";
      clearInterval(ballExecute);

      ballVelX = 0;
    }
    playerPositionY = playerPositionY + ballVel;
    playerPositionX = playerPositionX + ballVelX;
  }
    var ballExecute = setInterval(ballMult, 10)
}
function runFunc() {
  ballGravity();
  gameStarted = 2;
  drawTitleScreen();
  scrollOffsetTitleScreen = scroll;
  animateParticles("#e2320b")
  toggleExplosion = true;
  groundHeight = startx;
  playerPositionY = starty
  if (playerDead == true) {
    generateArrays();
    playerDead = false;
    playerPositionX = windowWidth/2;
    ballVelX = 0.4;
    fuelTrack = 10000;
    healthTrack = 150;
    tempTrack = 100;
    distTrack = 0;

  }
}
function groupOfGameOverEvents() {

}

var inputRotRight
var inputRotLeft
kd.W.down(function () {
input = true;
});
kd.W.up(function () {
 input = false;
});
kd.A.down(function () {
  inputRotLeft = true;
});
kd.A.up(function () {
 inputRotLeft = false;
});
kd.D.down(function () {
  inputRotRight = true;
});
kd.D.up(function () {
  inputRotRight = false;
});
// This update loop is the heartbeat of Keydrown
kd.run(function () {
  kd.tick();
});
  </script>
</html>
