<!DOCTYPE html>
<html lang="en" dir="ltr">

  <script>
  /*! keydrown - v1.2.7 - 2018-12-19 - http://jeremyckahn.github.com/keydrown */
;(function (window) {
var util = (function () {
  var util = {};
  /**
   * @param {Object} obj The Object to iterate through.
   * @param {function(*, string)} iterator The function to call for each property.
   */
  util.forEach = function (obj, iterator) {
    var prop;
    for (prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        iterator(obj[prop], prop);
      }
    }
  };
  var forEach = util.forEach;
  /**
   * Create a transposed copy of an Object.
   *
   * @param {Object} obj
   * @return {Object}
   */
  util.getTranspose = function (obj) {
    var transpose = {};
    forEach(obj, function (val, key) {
      transpose[val] = key;
    });
    return transpose;
  };
  /**
   * Implementation of Array#indexOf because IE<9 doesn't support it.
   *
   * @param {Array} arr
   * @param {*} val
   * @return {number} Index of the found element or -1 if not found.
   */
  util.indexOf = function (arr, val) {
    if (arr.indexOf) {
      return arr.indexOf(val);
    }
    var i, len = arr.length;
    for (i = 0; i < len; i++) {
      if (arr[i] === val) {
        return i;
      }
    }
    return -1;
  };
  var indexOf = util.indexOf;
  /**
   * Push a value onto an array if it is not present in the array already.  Otherwise, this is a no-op.
   *
   * @param {Array} arr
   * @param {*} val
   * @return {boolean} Whether or not the value was added to the array.
   */
  util.pushUnique = function (arr, val) {
    if (indexOf(arr, val) === -1) {
      arr.push(val);
      return true;
    }
    return false;
  };
  /**
   * Remove a value from an array.  Assumes there is only one instance of the
   * value present in the array.
   *
   * @param {Array} arr
   * @param {*} val
   * @return {*} The value that was removed from arr.  Returns undefined if
   * nothing was removed.
   */
  util.removeValue = function (arr, val) {
    var index = indexOf(arr, val);
    if (index !== -1) {
      return arr.splice(index, 1)[0];
    }
  };
  /**
   * Cross-browser function for listening for and handling an event on the
   * document element.
   *
   * @param {string} eventName
   * @param {function} handler
   */
  util.documentOn = function (eventName, handler) {
    if (window.addEventListener) {
      window.addEventListener(eventName, handler, false);
    } else if (document.attachEvent) {
      document.attachEvent('on' + eventName, handler);
    }
  };
  /**
   * Shim for requestAnimationFrame.  See:
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */
  util.requestAnimationFrame = (function () {
    return window.requestAnimationFrame  ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame    ||
      function( callback ){
        window.setTimeout(callback, 1000 / 60);
      };
  })();
  /**
   * An empty function.  NOOP!
   */
  util.noop = function () {};
  return util;
}());
/**
 * Lookup table of keys to keyCodes.
 *
 * @type {Object.<number>}
 */
var KEY_MAP = {
  'ZERO': 48,
  'ONE': 49,
  'TWO': 50,
  'THREE': 51,
  'FOUR': 52,
  'FIVE': 53,
  'SIX': 54,
  'SEVEN': 55,
  'EIGHT': 56,
  'NINE': 57,
  'A': 65,
  'B': 66,
  'C': 67,
  'D': 68,
  'E': 69,
  'F': 70,
  'G': 71,
  'H': 72,
  'I': 73,
  'J': 74,
  'K': 75,
  'L': 76,
  'M': 77,
  'N': 78,
  'O': 79,
  'P': 80,
  'Q': 81,
  'R': 82,
  'S': 83,
  'T': 84,
  'U': 85,
  'V': 86,
  'W': 87,
  'X': 88,
  'Y': 89,
  'Z': 90,
  'ENTER': 13,
  'SHIFT': 16,
  'ESC': 27,
  'SPACE': 32,
  'LEFT': 37,
  'UP': 38,
  'RIGHT': 39,
  'DOWN': 40,
  'BACKSPACE': 8,
  'DELETE': 46,
  'TAB': 9,
  'TILDE': 192
};
/**
 * The transposed version of KEY_MAP.
 *
 * @type {Object.<string>}
 */
var TRANSPOSED_KEY_MAP = util.getTranspose(KEY_MAP);
/*!
 * @type Array.<string>
 */
var keysDown = [];
var Key = (function () {
  'use strict';
  /**
   * Represents a key on the keyboard.  You'll never actually call this method
   * directly; Key Objects for every key that Keydrown supports are created for
   * you when the library is initialized (as in, when the file is loaded).  You
   * will, however, use the `prototype` methods below to bind functions to key
   * states.
   *
   * @param {number} keyCode The keyCode of the key.
   * @constructor
   * @class kd.Key
   */
  function Key (keyCode) {
    this.keyCode = keyCode;
    this.cachedKeypressEvent = null;
  }
  /*!
   * The function to be invoked on every tick that the key is held down for.
   *
   * @type {function}
   */
  Key.prototype._downHandler = util.noop;
  /*!
   * The function to be invoked when the key is released.
   *
   * @type {function}
   */
  Key.prototype._upHandler = util.noop;
  /*!
   * The function to be invoked when the key is pressed.
   *
   * @type {function}
   */
  Key.prototype._pressHandler = util.noop;
  /*!
   * Private helper function that binds or invokes a hander for `down`, `up',
   * or `press` for a `Key`.
   *
   * @param {Key} key
   * @param {string} handlerName
   * @param {function=} opt_handler If omitted, the handler is invoked.
   * @param {KeyboardEvent=} opt_evt If this function is being called by a
   * keyboard event handler, this is the raw KeyboardEvent Object provided from
   * the browser.
   */
  function bindOrFire (key, handlerName, opt_handler, opt_evt) {
    if (opt_handler) {
      key[handlerName] = opt_handler;
    } else {
      key[handlerName](opt_evt);
    }
  }
  /**
   * Returns whether the key is currently pressed or not.
   *
   * @method isDown
   * @return {boolean} True if the key is down, otherwise false.
   */
  Key.prototype.isDown = function () {
    return util.indexOf(keysDown, this.keyCode) !== -1;
  };
  /**
   * Bind a function to be called when the key is held down.
   *
   * @method down
   * @param {function=} opt_handler The function to be called when the key is
   * held down.  If omitted, this function invokes whatever handler was
   * previously bound.
   */
  Key.prototype.down = function (opt_handler) {
    bindOrFire(this, '_downHandler', opt_handler, this.cachedKeypressEvent);
  };
  /**
   * Bind a function to be called when the key is released.
   *
   * @method up
   * @param {function=} opt_handler The function to be called when the key is
   * released.  If omitted, this function invokes whatever handler was
   * previously bound.
   * @param {KeyboardEvent=} opt_evt If this function is being called by the
   * keyup event handler, this is the raw KeyboardEvent Object provided from
   * the browser.  This should generally not be provided by client code.
   */
  Key.prototype.up = function (opt_handler, opt_evt) {
    bindOrFire(this, '_upHandler', opt_handler, opt_evt);
  };
  /**
   * Bind a function to be called when the key is pressed.  This handler will
   * not fire again until the key is released â€” it does not repeat.
   *
   * @method press
   * @param {function=} opt_handler The function to be called once when the key
   * is pressed.  If omitted, this function invokes whatever handler was
   * previously bound.
   * @param {KeyboardEvent=} opt_evt If this function is being called by the
   * keydown event handler, this is the raw KeyboardEvent Object provided from
   * the browser.  This should generally not be provided by client code.
   */
  Key.prototype.press = function (opt_handler, opt_evt) {
    this.cachedKeypressEvent = opt_evt;
    bindOrFire(this, '_pressHandler', opt_handler, opt_evt);
  };
  /**
   * Remove the handler that was bound with `{{#crossLink
   * "kd.Key/down:method"}}{{/crossLink}}`.
   * @method unbindDown
   */
  Key.prototype.unbindDown = function () {
    this._downHandler = util.noop;
  };
  /**
   * Remove the handler that was bound with `{{#crossLink
   * "kd.Key/up:method"}}{{/crossLink}}`.
   * @method unbindUp
   */
  Key.prototype.unbindUp = function () {
    this._upHandler = util.noop;
  };
  /**
   * Remove the handler that was bound with `{{#crossLink
   * "kd.Key/press:method"}}{{/crossLink}}`.
   * @method unbindPress
   */
  Key.prototype.unbindPress = function () {
    this._pressHandler = util.noop;
  };
  return Key;
}());
var kd = (function (keysDown) {
  'use strict';
  /**
   * @class kd
   */
  var kd = {};
  kd.Key = Key;
  var isRunning = false;
  var now = Date.now
     ? Date.now
     : function () {return +new Date();};
  var previousUpdateTime = now();
  /**
   * Evaluate which keys are held down and invoke their handler functions.
   * @method tick
   */
  kd.tick = function () {
    var i, len = keysDown.length;
    for (i = 0; i < len; i++) {
      var keyCode = keysDown[i];
      var keyName = TRANSPOSED_KEY_MAP[keyCode];
      if (keyName) {
        kd[keyName].down();
      }
    }
  };
  /**
   * A basic run loop.  `handler` gets called approximately 60 times a second.
   *
   * @param {Function(number, number)} handler The callback function to call on
   * every tick.  You likely want to call [kd.tick](#method_tick) in this
   * function.  This callback receives the time elapsed since the previous
   * execution of the callback as the first parameter, and the current time
   * stamp as the second.
   * @method run
   */
  kd.run = function (handler) {
    isRunning = true;
    var currentTime = now();
    var timeSinceLastUpdate = currentTime - previousUpdateTime;
    util.requestAnimationFrame.call(window, function () {
      if (!isRunning) {
        return;
      }
      kd.run(handler);
      handler(timeSinceLastUpdate, currentTime);
    });
    previousUpdateTime = currentTime;
  };
  /**
   * Cancels the loop created by [run](#method_run).
   * @method stop
   */
  kd.stop = function () {
    isRunning = false;
  };
  // SETUP
  //
  // Initialize the KEY Objects
  util.forEach(KEY_MAP, function (keyCode, keyName) {
    kd[keyName] = new Key(keyCode);
  });
  util.documentOn('keydown', function (evt) {
    var keyCode = evt.keyCode;
    var keyName = TRANSPOSED_KEY_MAP[keyCode];
    var isNew = util.pushUnique(keysDown, keyCode);
    var key = kd[keyName];
    if (key) {
      var cachedKeypressEvent = key.cachedKeypressEvent || {};
      // If a modifier key was held down the last time that this button was
      // pressed, and it is pressed again without the modifier key being
      // released, it is considered a newly-pressed key.  This is to work
      // around the fact that the "keyup" event does not fire for the modified
      // key until the modifier button is also released, which poses a problem
      // for repeated, modified key presses such as hitting ctrl/meta+Z for
      // rapid "undo" actions.
      if (cachedKeypressEvent.ctrlKey ||
          cachedKeypressEvent.shiftKey ||
          cachedKeypressEvent.metaKey) {
        isNew = true;
      }
      if (isNew) {
        key.press(null, evt);
      }
    }
  });
  util.documentOn('keyup', function (evt) {
    var keyCode = util.removeValue(keysDown, evt.keyCode);
    var keyName = TRANSPOSED_KEY_MAP[keyCode];
    if (keyName) {
      kd[keyName].up(null, evt);
    }
  });
  // Stop firing the "down" handlers if the user loses focus of the browser
  // window.
  util.documentOn('blur', function (evt) {
    // Fire the "up" handler for each key that is currently held down
    util.forEach(keysDown, function (keyCode) {
      var mappedKey = TRANSPOSED_KEY_MAP[keyCode];
      if (mappedKey) {
        kd[mappedKey].up();
      }
    });
    keysDown.length = 0;
  });
  return kd;
 // The variables passed into the closure here are defined in kd.key.js.
}(keysDown));
if (typeof module === "object" && typeof module.exports === "object") {
  // Keydrown was loaded as a CommonJS module (by Browserify, for example).
  module.exports = kd;
} else if (typeof define === "function" && define.amd) {
  // Keydrown was loaded as an AMD module.
  define(function () {
    return kd;
  });
} else {
  window.kd = kd;
}
} (window));
  </script>
  <head>
    <meta charset="utf-8">
    <title></title>

<link href="https://fonts.googleapis.com/css?family=Orbitron|Questrial|Staatliches|ZCOOL+QingKe+HuangYou" rel="stylesheet">
    <!-- font-family: 'ZCOOL QingKe HuangYou', cursive;
        font-family: 'Staatliches', cursive;
        font-family: 'Questrial', sans-serif;
        font-family: 'Orbitron', sans-serif; -->
    <style media="screen">
      .statBarItem {
        font-family: 'Orbitron', sans-serif;
        font-size: 20px;
        color: white;
        transition: color 0.3s;
        float: left;
        margin: none;
        padding: none;
      }
      body {
        background: #1e1e1e;
        text-align: center;
      }
      .startButton {
        position: absolute;
        display: table;
        left: 0;
        right: 0;
        top: 0;
        width: 33.3%;
        height: 85px;
        margin: 270px 33.3%;
        z-index: 50;
        font-family: 'Orbitron', sans-serif;
        font-size: 30px;
        color: white;
        background: none;
        border: 2px solid white;
        transition: background 0.15s, color 0.15s, padding 0.15s, margin 0.15s, opacity 0.6s;
      }
      .startButton:hover {
        color: black;
        background: white;
      }
      #stats {
        position: absolute;
        height: 300px;
        width: 88%;
        margin-left: 2%;
        opacity: 0;
        left: 0;
        top: 0;
        z-index: 2;
        transition: opacity 0.6s;
      }
      .breakUpStats {
        text-align: right;
        position: relative;
        float: right;
        width: 350px;
      }
      #tempBar {
        position: absolute;
        height: 20px;
        width: 150px;
        background-image: linear-gradient(to right, blue , red);
        right: 0;

        border-radius: 2px;
      }
      #fuelBar {
        border-radius: 2px;
        position: absolute;
        left: 0;
        height: 20px;
        width: 150px;
        background-color: white;
        z-index: 1;
      }
      #meterBar {
        position: absolute;
        right: 0
        left: 75px;
        height: 20px;
        width: 4px;
        background: yellow;
      }
      #backDropBar {
        border-radius: 2px;
        position: relative;
        float: right;
        z-index: -1;
        width: 150px;
        margin-top: 25px;
        margin-left: 10px;
        height: 20px;
        background: #424242;
      }
      .rightStatBars {
        height: 50px;
        font-family: 'Orbitron', sans-serif;
        font-size: 20px;
        color: white;
        width: 300px;
        transition: color 0.3s;
        float: right;
      }
      #leftBars {
        float: left;
        width: 350px;
        opacity: 1;
        transition: opacity 0.2s;
      }
      #healthBar {
        border-radius: 2px;
        position: absolute;
        height: 20px;
        width: 150px;
        background-color: green;
        z-index: 1;
        left: 0;
      }
      .gameScreen {
        position: relative;
      }
      .titleBar {
        height: 600px;
        width: 1000px;
        test-align: center;
        position: absolute;
        left: 0;
        right: 0;
        margin: 12% auto;
        z-index: 200;
        opacity: 1;
        transition: opacity 0.6s;
      }
      #titleText {
        position: absolute;
        top: 0;
        opacity: 1;
        display: block;
        width: 95%;
        margin: -25px 2.5%;
        transition: opacity 0.6s;
      }
      .canvasBasic {
        padding: 0;
        background: none;
        position: absolute;
      }
      #usernameInput {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        width: 31.0%;
        padding: 1%;
        height: 50px;
        margin: 175px 33.3%;
        display: block;
        z-index: 1000;
        font-family: 'Orbitron', sans-serif;
        font-size: 30px;
        color: white;
        background: none;
        border: 2px solid white;
        transition: border 0.2s margin 0.2s;
      }
      #usernameInput:focus {
        margin: 171px 33.1%;
        border: 4px solid white;
      }
      .otherOptions {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        width: 33.3%;
        height: 85px;
        margin: 370px 33.3%;
        display: block;
        z-index: 50;
        font-family: 'Orbitron', sans-serif;
        font-size: 30px;
        color: white;
        background: none;
        transition: background 0.15s, color 0.15s, padding 0.15s, margin 0.15s, opacity 0.6s;
      }
      .options {
        position: absolute;
        z-index: 100px;
        float: left;
        background: none;
        height: 60%;
        width: 15%;
        border: 2px solid white;
        transition: background 0.15s, color 0.15s, padding 0.15s, margin 0.15s, opacity 0.6s;
      }
      .options:hover {
        background: white;
        color: black;
      }
      html, body {
        margin: 0;
        height: 100%;
        overflow: hidden;
      }
      #displayOfLeaderBoard {
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: -10000;
        opacity: 0;
      }
      .titleForLeaderBoard {
        top: 0;
        height: 12%;
        width: 100%;
        border-bottom: 1px solid white;
      }
      .boardOptions {
        position: absolute;
        height: 12%;
        width: 100%;
        top: 0;
        margin-top: 13%;
        border-bottom: 1px solid white;
      }
      .searchUsers {
      }
      #searchUsernames {
        position: absolute;
        right: 0;
        top: 0;
        width: 31.0%;
        padding: 1%;
        height: 40px;
        display: block;
        font-family: 'Orbitron', sans-serif;
        font-size: 30px;
        color: white;
        background: none;
        border: 2px solid white;
        transition: border 0.2s margin 0.2s;
      }
      #searchUsernames:focus {
        margin: -2px;
        border: 4px solid white;
      }
      .tableWithScroll {
        position: absolute;
        height: 65%;
        width: 100%;
        bottom: 0;
        overflow: auto;
      }
      #BackButton {
        position: absolute;
        font-family: 'Orbitron', sans-serif;
        font-size: 30px;
        color: white;
        background: none;
        border: 2px solid white;
        height: 65px;
        width: 15%;
        top: 0;
        left: 0;
        margin-top: 0px;
        transition: background 0.15s, color 0.15s, padding 0.15s, margin 0.15s, opacity 0.6s;
      }
      #BackButton:hover {
        background: white;
        color: black;
      }
      .boardWrite {
        width: 100%;
        top: 0;
        margin-top: 15px;
        font-size: 25px;
        font-family: 'Orbitron', sans-serif;
        color: white;
      }
      .rank {
        font-weight: bold;
        font-size: 30px;
      }
            /* width */
      ::-webkit-scrollbar {
        width: 25px;
      }
      /* Track */
      ::-webkit-scrollbar-track {
        background: none;
        border: 2px solid white;
      }
      /* Handle */
      ::-webkit-scrollbar-thumb {
        background: none;
        border: 2px solid white;
        transition: background 0.2s;
      }
      /* Handle on hover */
      ::-webkit-scrollbar-thumb:hover {
        background: white;
      }
      .boardHeaders {
        margin-top: -3px;
        padding-bottom: 20px;
        border-bottom: 1px solid white;
        font-size: 35px;
        margin-bottom: 15px;
      }
      .leaderRows {
        padding: 5px 0px;
      }
      #energyBar {
        border-radius: 2px;
        position: absolute;
        height: 20px;
        width: 150px;
        background-color: yellow;
        z-index: 2;
      }
      .centralStats {
        position: absolute;
        top: 0;
        width: 60%;
        height: 150px;
        margin: 15px 20%;
      }
      #rotationSensor {
        width: 100px;
        height: 150px;
        position: relative;
        margin-left: 50px;
        margin-bottom: 50px;
        margin-top: 25px;
        float: left;
      }
      #circleForRot {
        position: absolute;
        top: 0;
        left: 0;
        margin: 10px;
        height: 75px;
        width: 75px;
        border-radius: 50%;
        border: 3px solid white;
      }
      #lineVertical {
        position: absolute;
        top: 0;
        left: 0;
        height: 100px;
        width: 4px;
        margin: -12.5px 36px;
        background: white;
      }
      #fixedLineHorizontal {
        position: absolute;
        top: 0;
        left: 0;
        height: 4px;
        width: 78px;
        background-color: white;
        margin: 48px 10px;
      }
      #degreeContainer {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100px;
        height: 50px;
        text-align: center;
      }
      #degreeMonitor {
        color: white;
        font-family: 'Orbitron', sans-serif;
        font-size: 30px;
        margin: 0;
        padding: 10px 0px 9px 20px;
      }
      .trajectorCalculator {
        float: left;
        margin-left: 50px;
      }
      #trajectory {
        border: 2px solid white;
      }
      #buttonText {
        display: table-cell;
        vertical-align: middle;
      }
    </style>
  </head>
  <body>
    <div class="gameScreen" id="gameMainCont">
      <div class="titleBar" id="gameOptions" style="">
        <div id="TitleScreen">
          <div id="titleText">
            <p id="titleInfo" style="font-size: 70px; font-family: 'Orbitron', sans-serif; color: white;">Terrestrial Traveler</p>
          </div>
          <input id="usernameInput" type="text" name="" value="" placeholder=" username">
          <div id="accsesStartButton" class="startButton"><p id="buttonText">Play Game</p></div>

          <div class="otherOptions">
            <div class="options" id="info" style="margin-left: 0%;">
                <p type="button" style="font-family: 'Orbitron', sans-serif; font-size: 35px; margin-top: 5px;">i</p>
            </div>
            <div class="options" id="donate" style="margin-left: 42%">
              <p type="button" style="font-family: 'Orbitron', sans-serif; font-size: 35px; margin-top: 5px;">$</p>
            </div>
            <div class="options" id="leaderboard" style="margin-left: 84%">
              <p type="button" style="font-family: Helvetica; font-size: 70px; margin-top: -20px;">o</p>
            </div>
          </div>
        </div>

        <div id="displayOfLeaderBoard">
          <div class="titleForLeaderBoard">
            <h2 style="font-size: 60px; font-family: 'Orbitron', sans-serif; color: white;">Leader Board</h2>
          </div>
          <div class="boardOptions">
            <button id="BackButton" type="button" name="button">Back</button>
            <input id="searchUsernames"type="text" name="" value="" placeholder="Search">
          </div>
          <div class="tableWithScroll">
            <table class="boardWrite">
              <tr>
                <th class="boardHeaders">Rank</th>
                <th class="boardHeaders">Distance</th>
                <th class="boardHeaders">User</th>
              </tr>
              <script type="text/javascript">
              var recordOfScores = [];
              for (var v = 0; v < 50; v++) {
                recordOfScores.push({'rank':3, 'distance':`${12234}m`, 'username':'Jeff'});
                recordOfScores.push({'rank':8, 'distance':`${10845}m`, 'username':'Bob'});
              }
                for (var t = 0; recordOfScores[t] != null; t++) {
                  document.write(`<tr>`)
                  document.write(`<td class="rank leaderRows">${recordOfScores[t].rank}</td>`)
                  document.write(`<td class='leaderRows'>${recordOfScores[t].distance}</td>`)
                  document.write(`<td class='leaderRows'>${recordOfScores[t].username}</td>`)
                  document.write(`</tr>`)
                }
              </script>
            </table>
          </div>
        </div>

      </div>
      <div id="stats" style="">
        <div id="leftBars">
          <div class="breakUpStats" style="width: 250px;">
            <p class="statBarItem" id="fuel">Fuel: </p>
            <div id="backDropBar">
              <div id="fuelBar">
              </div>
            </div>
          </div>
          <div class="breakUpStats" style="width: 275px; margin-top: -25px;">
            <p class="statBarItem" id="health">Energy: </p>
            <div id="backDropBar">
              <div id="energyBar">
              </div>
            </div>
          </div>
          <div class="breakUpStats" style="width: 300px;">
            <p class="statBarItem" id="temp" style="margin-top: -5px; margin-left: -35px;">Temperature: </p>
            <div id="tempBar" style="position: absolute;">
              <div id="meterBar">
              </div>
            </div>
          </div>
          <div class="breakUpStats" style="width: 275px; margin-top: -25px;">
            <p class="statBarItem" id="health">Health: </p>
            <div id="backDropBar">
              <div id="healthBar">
              </div>
            </div>
          </div>
          <div class="breakUpStats">
            <div id="rotationSensor">
              <div id="fixedLineHorizontal">
              </div>
              <div id="circleForRot">
                <div id="lineVertical">
                </div>
              </div>
              <div id="degreeContainer">
                <p id="degreeMonitor">0 &#0176</p>
              </div>
            </div>
          </div>
          <div class="breakUpStats">
            <div class="trajectorCalculator">
              <canvas id="trajectory" width="100" height="100"></canvas>
            </div>
          </div>
        </div>

        <div class="centralStats">

        </div>
        <div class="breakUpStats">
          <p class="rightStatBars" id="dist">Distance: </p>
        </div>
      </div>
      <canvas id="canvas" class="canvasBasicWidths" height="1000" style="background: black; position: absolute; z-index: -10;"></canvas>
      <canvas id="ball" class="canvasBasic canvasBasicWidths" height="1000" style='z-index: -1;'></canvas>
      <canvas id="fire" class="canvasBasic canvasBasicWidths" height="1000" style='z-index: -2;'></canvas>
      <canvas id="stars" class="canvasBasic canvasBasicWidths" height="1000" style="z-index: -6;"></canvas>
      <canvas id="test" class="canvasBasic canvasBasicWidths" height="1000"  style="z-index: -5;"></canvas>
      <canvas id="enemy" class="canvasBasic canvasBasicWidths" height="1000"  style="z-index: -3;"></canvas>
      <canvas id="projectiles" class="canvasBasic canvasBasicWidths" height="1000"  style="z-index: -4;"></canvas>
      <canvas id="particles" class="canvasBasicWidths" height="1000" style="z-index: 1;"></canvas>
    </div>



  </body>
  <script type="text/javascript">
    var canv = document.getElementById("canvas");
    var ground = canv.getContext("2d");
    var tcanv = document.getElementById("test");
    var tester = tcanv.getContext("2d");
    var bcanv = document.getElementById('ball');
    var fcanv = document.getElementById('fire')
    var fire = fcanv.getContext('2d')
    var projCanv = document.getElementById('projectiles')
    var projectile = projCanv.getContext('2d')
    var scanv = document.getElementById('stars')
    var star = scanv.getContext('2d')
    var pcanv = document.getElementById('particles')
    var particles = pcanv.getContext('2d')
    var ecanv = document.getElementById('enemy')
    var enemies = ecanv.getContext('2d')
    var tcanv = document.getElementById('trajectory');
    var trajectory = tcanv.getContext('2d');
    var manualCanvasArr = [canv, tcanv, bcanv, fcanv, scanv, pcanv];
    var gameOptions = document.getElementById("gameOptions");
    var startButton = document.getElementById("accsesStartButton");
    var startButtonText = document.getElementById('buttonText');
    var fuel = document.getElementById("fuel");
    var temp = document.getElementById("temp");
    var dist = document.getElementById("dist");
    var statBar = document.getElementById("stats")
    var fuelMonitor = document.getElementById("fuelBar");
    var tempMonitor = document.getElementById("meterBar");
    var healthMonitor = document.getElementById("healthBar");
    var statLeft = document.getElementById("leftBars");
    var canvases = document.getElementsByClassName('canvasBasicWidths');
    var titleInformation = document.getElementById('titleInfo');
    var screenOfGame = document.getElementById('gameMainCont');
    var leaderBoard = document.getElementById('leaderboard');
    var userInput = document.getElementById('usernameInput');
    var leaderBoardDisplay = document.getElementById('displayOfLeaderBoard');
    var titleScreen = document.getElementById('TitleScreen');
    var backButton = document.getElementById('BackButton');
    var energyBar = document.getElementById('energyBar');
    var rotCircle = document.getElementById('circleForRot')
    var degreeMonitor = document.getElementById('degreeMonitor')
    var i;
    var titleScreenText = "Terrestrial Traveler"
    function drawStats(f, t, d, h, e, r) {
      var widthOfFuelBar = Math.floor(150 * (f/10000));
      var tempMonPos = Math.floor(150*t/200)-2;
      fuelMonitor.style.width = widthOfFuelBar.toString()+"px";
      tempMonitor.style.left = tempMonPos.toString()+"px";
      healthMonitor.style.width = h.toString()+"px";
      tempMonitor.style.width = "4px";
      tempMonitor.style.background = "yellow";
      energyBar.style.width = `${e}px`
      dist.innerHTML = "Distance: " + d + "m";
      statBar.style.opacity = 1;
      rotCircle.style.transform = `rotate(${r}deg)`
      degreeMonitor.innerHTML = r + "&#0176"
    }
    function drawTitleScreen() {
      gameOptions.style.opacity = "0";
      gameOptions.style.zIndex = -1000;
    }
    var test = [];
    var starPos = [];
    var landPositions = [];
    var enemyPositions = [];
    var currentUser = "";
    var blockSize = 1000/50;
    var variation = 10;
    var offset = 300;
    var lineBase = canv.height/2 + offset;
    var numberOfBlocks = 0;
    var windowWidth = window.innerWidth;
    var blockAmount = Math.ceil(windowWidth/blockSize)
    var canvasWidths = (blockSize*blockAmount) - (blockSize*3)
    var ticker = 1;
    var starTicker = 1;
    var requiredPadSize = 1;
    var scroll = 0;
    var playerDead = false;

    var toggleGradient = 1;

    function generateEnemies(start, end, frequency) {
      for (var o = start; o < end; o++) {
        // creates the positions for enemies and possibly other featurs
        var decider = Math.floor((Math.random() * frequency)+1)
        if (decider == 3 && enemyPositions[o-1] == 0) {
          enemyPositions[o] = 1;
        }
        else if (decider == 2 && enemyPositions[o-1] == 0) {
          enemyPositions[o] = 2;
        }
        else {
          enemyPositions[o] = 0;
        }
      }
    }

    function constructHillsBiome(spot, last, gradient, isUsedAsCraterOrHill, sizes) {
      var intensity = sizes == null ? 0.8 : sizes
      var randomHeight = (Math.random() * intensity)+intensity;//creats a random intensity for the parabola
      var lengthOfHill = Math.floor(Math.random() * 25)+4;// creates a random width for parabola
      var parabolaVertexY = Math.abs(gradient*randomHeight*Math.pow(lengthOfHill-(lengthOfHill/2), 2))+last*(gradient*-1);//gets max height of curve
      for (var q = 0; q <= lengthOfHill; q++) {
        test[q+spot] = (gradient*randomHeight*Math.pow(q - (lengthOfHill/2), 2))+parabolaVertexY*(gradient*-1);//vertex is half way through so half the length is the iterator's offset
        var noiseHeight = (Math.random() * 8) - 4;
        test[q+spot] += noiseHeight;

      }
      test[spot] = test[spot-1]+((test[spot+1] - test[spot-1])/2);
      return spot+lengthOfHill;//returns place in the main loop
    }
    function constructMountainsBiome(spot, last, gradient) {
      if (gradient < 0) {
        var randomRandom = Math.floor(Math.random()*30);
        var randomHeight = (Math.random() * randomRandom/2)+15;//creats a random intensity for the parabola
        var lengthOfHill = Math.floor(Math.random() * randomRandom)+15;// creates a random width for parabola
        var absValuePeak = (gradient*randomHeight*Math.abs(lengthOfHill/2))+last*(gradient);
      }
      else {
        var randomRandom = Math.floor(Math.random()*11);
        var randomHeight = (Math.random() * (randomRandom/3))+2;//creats a random intensity for the parabola
        var lengthOfHill = Math.floor(Math.random() * (randomRandom))+4;// creates a random width for parabola
        var parabolaVertexY = Math.abs(gradient*randomHeight*Math.pow(lengthOfHill-(lengthOfHill/2), 2))+last*(gradient*-1);//gets max height of curve
      }


      for (var q = 0; q <= lengthOfHill; q++) {
        var noise = Math.floor(Math.random() * 31);
        if (gradient < 0) {
          test[q+spot] = (gradient*randomHeight*Math.abs(q-(lengthOfHill/2)))+absValuePeak*gradient//abs value output instead of parabola output
        }
        else if (gradient > 0) {
          test[q+spot] = (gradient*randomHeight*Math.pow(q - (lengthOfHill/2), 2))+parabolaVertexY*(gradient*-1);//vertex is half way through so half the length is the iterator's offset
        }

        if (noise > 20 && noise < 30) {
          var noiseHeight = (Math.random() * 40) - 20;
          test[q+spot] += noiseHeight;
        }
        else if (noise > 1 && noise < 4) {
          var noiseHeight = (Math.random() * 6) - 3;
          test[q+spot] = test[q+spot-1] + noiseHeight
          lengthOfHill+1;
        }
      }
      test[spot] = test[spot-1]+((test[spot+1] - test[spot-1])/2);
      return spot+lengthOfHill;//returns place in the main loop
    }
    function constructFlatLandBiome(spot, last, gradient) {
      var noiseHeight = (Math.random() * 10) - 5;
      test[spot] = last + noiseHeight;
      return spot;
    }
    function constructStrongHold(center, length) {
        var flatLength = Math.floor(length/4);
        var halfLength = Math.floor(length/2);
        var newCenter = center + Math.floor(flatLength/2);

        for (var q = 0; q < flatLength; q++) {
          test[center+q] = test[center-1];
        }
        for (var q = 0; q < (flatLength*5); q++) {
          if (q<flatLength || q>flatLength*4) {
            var decider = Math.floor(Math.random()*25)+1;
          }
          else if (q>=flatLength && q<flatLength*2 || q<=flatLength*4  && q>flatLength*3) {
            var decider = Math.floor(Math.random()*19)+1;
          }
          else {
            var decider = 0;
          }

          if (decider == 3) {
            enemyPositions[center-(halfLength-q)] = 1;
          }
          else if (decider == 2) {
            enemyPositions[center-(halfLength-q)] = 2;
          }
          else {
            enemyPositions[center-(halfLength-q)] = 0;
          }
        }
      enemyPositions[newCenter] = 3;
      return center + flatLength-1;
    }

    var biome = Math.floor(Math.random() * 3);
    ////////////
    function generateChunck(placeSoFar, previouseBiome) {
      while (biome==previouseBiome) {
        biome = Math.floor(Math.random() * 3);
      }
      var biomeLength = Math.floor(Math.random() * 850) + 900;
      generateEnemies(placeSoFar, placeSoFar+biomeLength, 260);
      var numberOfStrongHolds = 1;
      // numberOfStrongHolds += Math.random() * 1 > 0.8 ? 1 : 0;
      var strongHoldSeeds = []
      for (var q = 0; q <= numberOfStrongHolds; q++) {
        strongHoldSeeds[q] = Math.floor(Math.random() * biomeLength);
        while (strongHoldSeeds[q] < 300 || strongHoldSeeds[q] > biomeLength - 200) {
          strongHoldSeeds[q] = Math.floor(Math.random() * biomeLength);
        }
      }
      var strongHoldLength = Math.floor(Math.random() * 50) + 50;
      for (x=placeSoFar; x<placeSoFar+biomeLength; x++) {
        for (var q = 0; q < strongHoldSeeds.length; q++) {

        }
        if (x==0) {
          test[x] = 60;
        }
        else if (x>=strongHoldSeeds[0] && strongHoldSeeds[0] != 0) {
          strongHoldSeeds[0] = 0;
          x = constructStrongHold(x, strongHoldLength);
        }
        else if (biome == 0 && x != 0) {
          x = constructHillsBiome(x-1, test[x-1], toggleGradient);//toggleGradient will be used to flip curve, not implemented yet
          toggleGradient *= -1;
        }
        else if (biome == 1 && x != 0) {
          x = constructMountainsBiome(x-1, test[x-1], toggleGradient);//toggleGradient will be used to flip curve, not implemented yet
          var secondPeak = Math.random() * 1 > 0.45 ? 1 : -1;
          toggleGradient *= toggleGradient == 1 ? -1 : secondPeak;
        }
        else if (biome == 2 && x != 0) {
          var chanceOfHill = Math.floor(Math.random() * 260);
          if (chanceOfHill == 20) {
            var hillOrCrater = Math.random() * 1 > 0.5 ? -1 : 1;
            x = constructHillsBiome(x-1, test[x-1], toggleGradient, true, 0.5);//toggleGradient will be used to flip curve, not implemented yet
            toggleGradient *= hillOrCrater;
          }
          else {
            x = constructFlatLandBiome(x, test[x-1])
          }
        }
      }

      return biomeLength;
    }
    for (var b = -40; b < 10000; b++) {
      starPos[b] = Math.floor((Math.random() * (scanv.height-(lineBase*0.3)))+1);
    }

    generateChunck(test.length, biome);

    function calculateLandingSpots() {
      for (var n = 0; n < test.length; n++) {

        var slopeDifference = 0;
        var startToEnd = 0;
        slopeDifference = test[n] - test[n+1];
        landPositions[n] = 0;

        while (slopeDifference < 3 && slopeDifference > -3) {
          n = n + 1;
          landPositions[n] = 0;
          startToEnd = startToEnd + 1;
          slopeDifference = test[n] - test[n+1];
        }
        if (startToEnd > requiredPadSize) {
          //n will have startToEnd taken from it
          //this will avoid a endless loop beacause if n
          //is overly manipulated, it could cause endless loop
          for (var l = n - startToEnd+1; l <= n; l++) {
            landPositions[l] = 1;
          }
        }
      }
    }
    calculateLandingSpots();
    ///For END For END For END For END For END For END For END For END For END
    function drawStars(starX, starY) {
      if (i==0+starTicker-1) {
        scanv.width = canvasWidths;
        star.translate(0-scroll/2, 0);
      }
      // star.arc(x, y, 2, 0, 2 * Math.PI);
      star.beginPath();
      star.moveTo(starX, starY);
      star.lineTo(starX+2, starY-2);
      star.lineTo(starX, starY-4);
      star.lineTo(starX-2, starY-2);
      star.closePath();
      star.fillStyle = "white";
      var yDeterminer = objAboveGround(starX, starY, starTicker, scroll/2);
      if (starY < yDeterminer) {
        star.fill();
      }
    }
    var executeFill = false;
    function createLineBlock(starty, endy, color) {
      if (i==0+ticker-1) {
        canv.width = canvasWidths;
        ground.translate(0-scroll, 0)
      }
      ground.beginPath();
      ground.moveTo(blockSize * (i-1), starty);
      ground.lineTo(blockSize * (i), endy);
      ground.strokeStyle = color
      ground.stroke();
    }
    var playerRotation = 60;
    var playerVelocityX = 0.7;
    var xMult;
    var yMult;
    var playerPositionX = canvasWidths/2;
    //uses the numbers that created the visual line to create a tangable y position of the ground based on player's x position
    function objAboveGround(x, objY, whichTicker, whatLevelOfScroll, chooseReturn) {
      var trueTick = whichTicker - 1;
      var realScroll = whatLevelOfScroll
      var scrollOffset = realScroll - blockSize*(trueTick);
      var zoneCount = Math.trunc((x+realScroll)/blockSize);
      var zoneCountRight = Math.trunc((10+x+realScroll)/blockSize);
      var zoneCountLeft = Math.trunc((10-x+realScroll)/blockSize);
      var difference1;
      var addStep1;
      var finalAddStep1;
      var heightOfGround;
      if (i == 0+starTicker-1) {
        heightOfGround = lineBase - test[trueTick];
        difference1 = test[trueTick] - test[zoneCount + 1]
      }
      difference1 = test[zoneCount] - test[zoneCount + 1]
      addStep1 = Math.ceil((((x+realScroll)-(zoneCount*blockSize))/blockSize)*100)/100
      // addStep = Math.ceil((Math.trunc(playerPositionX+scroll/blockSize) - (playerPositionX+scroll/blockSize))*100)/100;
      finalAddStep1 = -(difference1 * addStep1)
      heightOfGround = lineBase - (test[zoneCount] + finalAddStep1);
      // +(scroll-(blockSize*(ticker-1)))\
      switch (chooseReturn) {
        case 1:
          return heightOfGround;
        break;
        case 2:
          return zoneCount;
        break;
        case 3:
          return zoneCountLeft;
        break;
        case 4:
          return zoneCountRight;
        break;
        default:
          return heightOfGround + 1;
      }
    }

/////// Paricles Function
    var particleIndex = [];
    function createParticles(instX, instY, color, speed, pcount, duration) {
      for (var q = 0; q < pcount; q++) {
        if (duration != null) {
          var randomDeterminer = duration;
        }
        else {
          var randomDeterminer = 200;
        }
        var randomLife = Math.floor(Math.random()*randomDeterminer);
        var directionX = Math.random() < 0.5 ? -1 : 1;
        var directionY = Math.random() < 0.5 ? -1 : 1;
        var randomXVel = (Math.random()*speed)+0.2;
        var randomYVel = (Math.random()*speed)+0.2;
        particleIndex.push({'xVel':randomXVel*directionX, 'yVel':randomYVel*directionY, 'xPos':instX, 'yPos':instY, 'color':color, 'lifeLived':0, 'lifeSpan':randomLife, 'id':'general'});
      }
    }
    function createFireParticles(startRed, startGreen, startBlue, endRed, endGreen, endBlue,
                                  shipX, shipY, shipVelX, shipVelY, shipRotation, exhaustZone) {
      var randomLife = Math.floor(Math.random()*75)+15;
      var randomXVel = (Math.random()*1)-0.5;
      var randomYVel = (Math.random()*1)-0.5;
      var spawnVariationX = (Math.random()*6)-3;
      var spawnVariationY = (Math.random()*6)-3;
      var redChange = startRed - endRed;
      var greenChange = startGreen - endGreen;
      var blueChange = startBlue - endBlue;
      if (exhaustZone == null) {
        var offsetY = 21*(1-(Math.abs(shipRotation)/90))
        var offsetX = 21*(shipRotation/90)*-1
        var velYDirect = 3*(1-(Math.abs(shipRotation)/90))
        var velXDirect = 6*(shipRotation/90)
      }
      if (exhaustZone == 1) {
        var offsetY = 0;
        var offsetX = 0;
        var xSubtract = shipRotation>=0 ? 1 : -1;
        var velYDirect = 6*(shipRotation/90)
        var velXDirect = (6*-(shipRotation/90))
      }

        particleIndex.push({'xVel':randomXVel+velXDirect*-1, 'yVel':randomYVel+velYDirect, 'xPos':shipX+offsetX+spawnVariationX, 'yPos':shipY+offsetY+spawnVariationY, 'lifeLived':0, 'lifeSpan':randomLife, 'id':'exhaust',
        'red':startRed, 'green':startGreen, 'blue':startBlue, 'redChange':redChange, 'greenChange':greenChange, 'blueChange':blueChange});
    }
var ball = bcanv.getContext("2d");
var playerPositionY = 100;
var playerVelocityY = 0;
var input = false;
function drawCircle(x, y, rot, color, offset) {
  ball.beginPath()
  ball.translate(x, y);
  ball.rotate(playerRotation * Math.PI / 180)
  ball.beginPath();
  ball.moveTo(0, -40);
  ball.lineTo(-15, -20);
  ball.lineTo(15, -20);
  ball.closePath();
  ball.moveTo(-15, 20);
  ball.lineTo(-15, 30);
  ball.lineTo(-5, 20);
  ball.closePath();
  ball.moveTo(15, 20);
  ball.lineTo(15, 30);
  ball.lineTo(5, 20);
  ball.rect(-15, -20, 30, 40);
  ball.fillStyle = color;
  ball.fill();
  ball.closePath()
  ball.beginPath();
  ball.moveTo(-15, 2.5);
  ball.lineTo(-offset-15, 2.5);
  ball.lineTo(-offset-15, 7.5);
  ball.lineTo(-15, 7.5);
  ball.lineTo(-15, 2.5);
  ball.fillStyle = color;
  ball.fill();
  ball.closePath();

}
  var gameStarted = 5;
  var canUseFire = true;


var spaceShipColor = "rgb(255, 255, 255)"
var spaceShipColorValues = {'differenceRed':0, 'differenceGreen':0, 'differenceBlue':0, 'animProgress':0, 'animStarted':false, 'returnToNormal':false}

function spaceShipColorAnimation(red, green, blue) {
  spaceShipColorValues.differenceRed = 255-red;
  spaceShipColorValues.differenceGreen = 255-green;
  spaceShipColorValues.differenceBlue = 255-blue;
  spaceShipColorValues.animProgress = 0;
  spaceShipColorValues.returnToNormal = false;
  spaceShipColorValues.animStarted = true;
}

drawCircle(playerPositionX, playerPositionY, playerRotation, spaceShipColor);
  function calcBulletVelocety(gunRot, power, select) {
    var ratioCreate = 0;
    var xVelBullet = 0;
    var yVelBullet = 0;
    //direction system is like a 4 quaderant coordinate system
    var direction = 1;
    var directiony = 1;
    if (gunRot>=1 && gunRot<1.5) {
      ratioCreate = (gunRot-1)*2;
      direction = -1;
      directiony = 1;
    }
    else if (gunRot>=1.5 && gunRot<2) {
      ratioCreate = (0.5-(gunRot-1.5))*2;
      direction = 1;
      directiony = 1;
    }
    else if (gunRot>=0 && gunRot<0.5) {
      ratioCreate = (gunRot)*2;
      direction = 1;
      directiony = -1;
    }
    else if (gunRot>=0.5 && gunRot<1) {
      ratioCreate = (0.5-(gunRot-0.5))*2;
      direction = -1;
      directiony = -1;
    }
    yVelBullet = power * ratioCreate;
    xVelBullet = power - yVelBullet;
    if (select == "x") {
      return xVelBullet*direction;
    }
    else if (select == "y") {
      return yVelBullet*directiony;
    }
  }
  bullets = [];
  var bulletSpeed = 9;
  //{'xPos':0, 'yPos':0, 'xVel':0, 'yVel':0, 'lifeSpan':350}
  function bulletInstantiate(gunRot, enemyX, enemyY, condition, charge) {
    if(condition == 1) {
      var xVelo = gunRot;
      bullets.push({'xPos':enemyX, 'yPos':enemyY, 'xVel':xVelo, 'yVel':charge, 'lifeSpan':350, 'particlesColor':true, 'id':'player'});
    }
    else if (condition == 2) {
      bullets.push({'xPos':enemyX, 'yPos':enemyY-13, 'xVel':0, 'yVel':charge, 'lifeSpan':300, 'id':'homer', 'positionHistory':[]});
    }
    else {
      bullets.push({'xPos':enemyX, 'yPos':enemyY, 'xVel':calcBulletVelocety(gunRot, bulletSpeed, 'x'), 'yVel':calcBulletVelocety(gunRot, bulletSpeed, 'y')*-1, 'lifeSpan':450, 'id':'enemy', 'positionHistory':[{'x':enemyX, 'y':enemyY-8}]});
    }
  }
  function energyUpInstantiate(relX, relY, size) {
    ////// Must tediously draw the graphic through code when using canvas
    enemies.beginPath();
    enemies.moveTo(relX, relY);
    enemies.lineTo(relX+(3*size), relY-(8*size));
    enemies.lineTo(relX+(size*0.5), relY-(8.25*size));
    enemies.lineTo(relX+(1*size), relY-(11*size));
    enemies.lineTo(relX-(2*size), relY-(11*size));
    enemies.lineTo(relX-(1.5*size), relY-(6.5*size));
    enemies.lineTo(relX+(0.5*size), relY-(6*size));
    enemies.lineTo(relX, relY);
    enemies.closePath();
    enemies.fillStyle = "#ffd82d";
    enemies.strokeStyle = "#e08743"
    enemies.fill();
    enemies.stroke();
    enemies.closePath();
  }
  function healthInstantiate(relX, relY, size) {
    ////// Must tediously draw the graphic through code when using canvas
    enemies.beginPath();
    enemies.moveTo(relX, relY);
    enemies.lineTo(relX+(1*size),relY);
    enemies.lineTo(relX+(1*size),relY+(2.5*size));//
    enemies.lineTo(relX+(3.5*size),relY+(2.5*size));//
    enemies.lineTo(relX+(3.5*size),relY+(4.5*size));//
    enemies.lineTo(relX+(1*size),relY+(4.5*size));//
    enemies.lineTo(relX+(1*size),relY+(7*size));
    enemies.lineTo(relX+(-1*size),relY+(7*size));
    enemies.lineTo(relX+(-1*size),relY+(4.5*size));
    enemies.lineTo(relX+(-3.5*size),relY+(4.5*size));
    enemies.lineTo(relX+(-3.5*size),relY+(2.5*size));
    enemies.lineTo(relX+(-1*size),relY+(2.5*size));
    enemies.lineTo(relX+(-1*size),relY);
    enemies.lineTo(relX, relY);
    enemies.closePath();
    enemies.fillStyle = "green";
    enemies.strokeStyle = "white"
    enemies.fill();
    enemies.stroke();
    enemies.closePath();
  }

  function drawOctagon(xPosition, yPostion, radius, leftLimit, rightLimit) {
    enemies.beginPath();
    enemies.moveTo(xPosition, yPostion);
    enemies.arc(xPosition, yPostion, radius, leftLimit*Math.PI, leftLimit*Math.PI);
    for (var q = 0; q <= 8; q++) {
      if (0.25*q>leftLimit && 0.25*q<rightLimit && rightLimit>0.5 || 0.25*q>leftLimit && 0.25*q>rightLimit && rightLimit<0.5) {
        enemies.arc(xPosition, yPostion, radius, (0.25*q)*Math.PI, (0.25*q)*Math.PI)
      }
    }
    enemies.arc(xPosition, yPostion, radius, rightLimit*Math.PI, rightLimit*Math.PI);
    enemies.lineTo(xPosition, yPostion);
    enemies.fillStyle = "red"
    enemies.strokeStyle = "rgba(255, 255, 255, 0.5)"
    enemies.strokeWidth = 3;
    enemies.fill();
    enemies.stroke();
    enemies.closePath();
  }

function createGunAngle(playPosx, playPosy, enemyXPosition, enemyYPosition, offset) {
    var gunRefX = (enemyXPosition-offset)-playPosx;
    var gunRefY = enemyYPosition-playPosy;
    if (gunRefY<0) {
      var gunAngleCreate = (Math.atan(gunRefY/gunRefX))*180/Math.PI
      ///gunAngleCreate is still in degree form at this point
      if (gunAngleCreate<0) {
        gunAngleCreate = 1+((gunAngleCreate/90)/2)
      }
      else {
        gunAngleCreate = (gunAngleCreate/90)/2
      }
    }
    else {
      // gets angle in degrees then converts them to the 0-2 PI form that arc uses
      var gunAngleCreate = 1.5+(((-1*((Math.atan(gunRefX/gunRefY))*180/Math.PI))/90)/2)
    }
    return gunAngleCreate;
  }

  var enemiesHold = [];
  var trackOfEnemies = [];
  function drawEnemy(x, y, id, reference, type) {
    var calcOrNot = trackOfEnemies.indexOf(id);
    if (calcOrNot < 0) {
      if (type == 1 || type == 2) {
        var leftEdge = lineBase-test[id-1]
        var rightEdge = lineBase-test[id+1]
        var trueY = lineBase-test[id];
        var leftAngle = 1+((((Math.atan((trueY-leftEdge)/(blockSize)))*180/Math.PI)/90)/2)
        var rightAngle = 2+((((Math.atan((trueY-rightEdge)/(blockSize)))*180/Math.PI)/90)/-2)
        if (rightAngle>2) {
          rightAngle -= 2;
        }
        var leftEdge2 = lineBase-test[id-2]
        var rightEdge2 = lineBase-test[id+2]
        var leftAngleExtended = 1+((((Math.atan((trueY-leftEdge2)/(blockSize*2)))*180/Math.PI)/90)/2)
        var rightAngleExtended = 2+((((Math.atan((trueY-rightEdge2)/(blockSize*2)))*180/Math.PI)/90)/-2)
        if (rightAngleExtended>2) {
          rightAngleExtended -=2
        }

        if (type == 1) {
          var coolDown = Math.floor(Math.random() * 150) + 170;
          var enemyType = "shooter";
        }
        else if (type == 2) {
          var coolDown =  Math.floor(Math.random() * 100) + 50;
          var enemyType = "homer";
        }
        enemiesHold.push({
          'enemyID':id,
          'leftAngle':leftAngle,
          'rightAngle':rightAngle,
          'leftAngleExtended':leftAngleExtended,
          'rightAngleExtended':rightAngleExtended,
          'gunRotation':1.5,
          'alive':true,
          'dropID': 1, //Math.floor(Math.random(3)+1),
          'bulletCoolDown':0,
          'coolDown':coolDown,
          'canShoot':true,
          'type':enemyType
        });
      }
      else if (type == 3) {
        var rightSide = test[id-1];
        var leftSide = test[id+1];
        var createFluidPoints = []
        for (var q = 0; q < 10; q++) {
          createFluidPoints[q] = {'position':Math.random() * 2.25, 'direction':1};
        }
        enemiesHold.push({
          'enemyID':id,
          'rightSide':rightSide,
          'leftSide':leftSide,
          'fuelLevel':50,
          'fluidPoints':createFluidPoints,
          'type':"fuelTank"
        });
      }
      trackOfEnemies.push(id);
    }

    if (enemiesHold[reference] != null && enemiesHold[reference].type == "fuelTank") {
      if (playerPositionX-armLength-15+scroll<x+blockSize && playerPositionY>y-(blockSize*2) && playerPositionX-armLength+scroll>x-blockSize && contactMade == true) {
        enemiesHold[reference].fuelLevel -= 0.05;
        armContact = true;
        if (enemiesHold[reference].fuelLevel > 0) {
          fuelTrack += 2;
        }
      }
      else {
        armContact = false;
      }
      enemies.beginPath();
      enemies.moveTo(x-(blockSize), y);
      enemies.lineTo(x-(blockSize), y-(blockSize*2.5));
      enemies.lineTo(x+(blockSize), y-(blockSize*2.5));
      enemies.lineTo(x+(blockSize), y);
      enemies.lineTo(x-(blockSize), y);
      enemies.fillStyle = "#b7b7b7";
      enemies.fill();
      enemies.closePath();

      enemies.beginPath();
      enemies.moveTo(x-(blockSize), y);
      for (var q = 0; q < enemiesHold[reference].fluidPoints.length; q++) {
        if (enemiesHold[reference].fluidPoints[q].direction==1 && enemiesHold[reference].fluidPoints[q].position>2.25) {
          enemiesHold[reference].fluidPoints[q].direction = -1;
        }
        else if (enemiesHold[reference].fluidPoints[q].direction==-1 && enemiesHold[reference].fluidPoints[q].position<0) {
          enemiesHold[reference].fluidPoints[q].direction = 1;
        }
        enemiesHold[reference].fluidPoints[q].position += 0.05*enemiesHold[reference].fluidPoints[q].direction;
        enemies.lineTo((((blockSize*2)/enemiesHold[reference].fluidPoints.length+1)*q)+(x-blockSize), y-(blockSize*(2*(enemiesHold[reference].fuelLevel/50))) + enemiesHold[reference].fluidPoints[q].position);
      }
      enemies.lineTo(x+(blockSize), y);
      enemies.lineTo(x-(blockSize), y);
      enemies.fillStyle = "black";
      enemies.fill();
      enemies.closePath();
      enemies.beginPath();
      enemies.moveTo(x-(blockSize), y);
      enemies.lineTo(x-(blockSize), y-(blockSize*2.5));
      enemies.moveTo(x+(blockSize), y-(blockSize*2.5));
      enemies.lineTo(x+(blockSize), y);
      enemies.lineTo(x-(blockSize)-1.5 , y);
      enemies.lineWidth = 3;
      enemies.strokeStyle = "white";
      enemies.stroke();
      enemies.closePath();
    }
    if (enemiesHold[reference] != null && enemiesHold[reference].alive == true && enemiesHold[reference].type == "shooter") {
      var gunAngle = createGunAngle(playerPositionX + (playerVelocityX*40), playerPositionY + (playerVelocityY*15), x, y, scroll);

      var checkGunAngleRight = gunAngle+0.075;
      if (checkGunAngleRight>2) {
        checkGunAngleRight-=2
      }
      var checkGunAngleLeft = gunAngle-0.075;
  ///////// ALL THE CONDITIONS THAT PREVENT THE GUN FROM ROTATING ||||| could have likely made an if statement with opposite conditions and avoided an else statement, but both cases have same result
      if (checkGunAngleRight>=enemiesHold[reference].rightAngle && enemiesHold[reference].rightAngle>=0.5 ||
          checkGunAngleRight>=enemiesHold[reference].rightAngleExtended && enemiesHold[reference].rightAngleExtended>=0.5 ||
          checkGunAngleLeft<=enemiesHold[reference].leftAngle && checkGunAngleLeft > 0.5 ||
          checkGunAngleLeft<=enemiesHold[reference].leftAngleExtended && checkGunAngleLeft > 0.5 ||
          checkGunAngleRight>=enemiesHold[reference].rightAngle && enemiesHold[reference].rightAngle>=0 && enemiesHold[reference].rightAngle<=0.5 && checkGunAngleRight<0.5 ||
          checkGunAngleRight>=enemiesHold[reference].rightAngleExtended && enemiesHold[reference].rightAngleExtended>=0 && enemiesHold[reference].rightAngleExtended<=0.5 && checkGunAngleRight<0.5 ||
          checkGunAngleRight<=enemiesHold[reference].rightAngle && checkGunAngleRight<0.5 && enemiesHold[reference].rightAngle>0.5 ||
          checkGunAngleRight<=enemiesHold[reference].rightAngleExtended && checkGunAngleRight<0.5 && enemiesHold[reference].rightAngleExtended>0.5) {
        enemiesHold[reference].gunRotation = enemiesHold[reference].gunRotation;
      }
      else {
        enemiesHold[reference].gunRotation = gunAngle;
      }
      /// hecktic if statements due to the 0-2PI method of arc()
      var rightVisualGunLine = enemiesHold[reference].gunRotation+0.075;
      var leftVisualGunLine = enemiesHold[reference].gunRotation-0.075;
      if (leftVisualGunLine<0) {
        leftVisualGunLine+=2;
      }
      if (rightVisualGunLine>2) {
        rightVisualGunLine-=2;
      }

      enemies.beginPath();
      enemies.moveTo(x, y);
      enemies.arc(x, y, blockSize*2, leftVisualGunLine*Math.PI, rightVisualGunLine*Math.PI)
      enemies.lineTo(x, y);
      enemies.arc(x, y, blockSize, enemiesHold[reference].leftAngle*Math.PI, enemiesHold[reference].rightAngle*Math.PI);
      enemies.lineTo(x, y);
      enemies.fillStyle = "rgba(50, 100, 255, 1)";
      enemies.closePath();
      enemies.lineWidth = 3;
      enemies.strokeStyle = "rgba(185, 150, 255, 0.5)";
      enemies.stroke();
      enemies.fill();
      enemies.closePath();

      enemiesHold[reference].bulletCoolDown += 1;
      if (enemiesHold[reference].canShoot == false) {
        if (enemiesHold[reference].bulletCoolDown>enemiesHold[reference].coolDown) {
          enemiesHold[reference].canShoot = true;
        }
      }
      else if (enemiesHold[reference].canShoot == true && enemiesHold[reference].alive == true) {
        bulletInstantiate(enemiesHold[reference].gunRotation, x, y)
        enemiesHold[reference].bulletCoolDown = 0;
        enemiesHold[reference].canShoot = false;
        //enemiesHold[reference].gunRotation
      }
    }
    else if (enemiesHold[reference] != null && enemiesHold[reference].alive == false && enemiesHold[reference].type == "shooter") {
      energyUpInstantiate(x, y, 5);
      if (playerPositionY > y-(blockSize*2.5) && playerPositionY < y+(blockSize*2.5) &&
         (playerPositionX) > x-(blockSize*2.5)-scroll && (playerPositionX) < x+(blockSize*2.5)-scroll &&
          playerInvinsibility <=0 && playerStarted == true) {
        enemiesHold[reference].type = "None";
        spaceShipColorAnimation(255, 255, 0);
        energyTrack += 50
      }
    }
    else if (enemiesHold[reference] != null && enemiesHold[reference].alive == true && enemiesHold[reference].type == "homer") {
      drawOctagon(x, y, blockSize, enemiesHold[reference].leftAngle, enemiesHold[reference].rightAngle);
      enemiesHold[reference].bulletCoolDown += 1;
      if (enemiesHold[reference].canShoot == false) {
        if (enemiesHold[reference].bulletCoolDown>enemiesHold[reference].coolDown) {
          enemiesHold[reference].canShoot = true;
        }
      }
      else if (enemiesHold[reference].canShoot == true && enemiesHold[reference].alive == true) {
        bulletInstantiate(0, x, y, 2, -0.6)
        enemiesHold[reference].bulletCoolDown = 0;
        enemiesHold[reference].canShoot = false;
        //enemiesHold[reference].gunRotation
      }
    }
    else if (enemiesHold[reference] != null && enemiesHold[reference].alive == false && enemiesHold[reference].type == "homer") {
      healthInstantiate(x, y, -5);
      if (playerPositionY > y-(blockSize*2.5) && playerPositionY < y+(blockSize*2.5) &&
         (playerPositionX) > x-(blockSize*2.5)-scroll && (playerPositionX) < x+(blockSize*2.5)-scroll &&
          playerInvinsibility <=0 && playerStarted == true) {
        enemiesHold[reference].type = "None";
        spaceShipColorAnimation(0, 255, 0);
        healthTrack += 50
      }

    }

    //Inefficient way to check if enemy is hit
    for (var q = 0; q < bullets.length; q++) {
      if (bullets[q].yPos > y-(blockSize*1.5) && bullets[q].yPos < y+(blockSize*1.5) &&
         (bullets[q].xPos) > x-(blockSize*1.5) && (bullets[q].xPos) < x+(blockSize*1.5)) {

        if (bullets[q].id == "shooter" && bullets[q].lifeSpan <= 420 || bullets[q].id == "player" && bullets[q].lifeSpan <= 350) {
          if (enemiesHold[reference].alive==true) {
            if(enemiesHold[reference].type=="shooter") createParticles(x, y, "rgba(50, 100, 255)", 5, 200);
            if(enemiesHold[reference].type=="homer") createParticles(x, y, "rgba(255, 5, 0)", 5, 200);
            bullets.splice(q, 1);
            enemiesHold[reference].alive = false;
          }
          else if (enemiesHold[reference].alive==false) {
            if(enemiesHold[reference].type=="shooter") createParticles(x, y, "rgba(255, 255, 0)", 5, 200);
            if(enemiesHold[reference].type=="homer") createParticles(x, y, "rgba(0, 255, 0)", 5, 200);
            bullets.splice(q, 1);
          }
        }
      }
    }
  }
  function drawTragectory(xVelT, yVelT, grav) {
    tcanv.width = 100;
    tcanv.height = 100;
    trajectory.translate(50, 50);
    var positionX = 0;
    var positionY = 0;
    var yVelococity = yVelT;
    trajectory.arc(0, 0, 2, 0, 2*Math.PI)
    trajectory.fillStyle = "white";
    trajectory.fill();
    trajectory.moveTo(0, 0);
    for (var v = 0; v < 120; v++) {
      yVelococity = yVelococity + grav;
      positionY = positionY + yVelococity;
      positionX = positionX + xVelT;
      trajectory.lineTo(positionX, positionY);
    }
    trajectory.lineWidth = 3;
    trajectory.setLineDash([3,2]);
    trajectory.strokeStyle = "white";
    trajectory.stroke();
  }
  // drawTragectory(0.5, 0.5, 0.3);
var gravityMult = 0.004
var contactMade = false;
var fuelTrack = 10000;
var healthTrack = 150;
var tempTrack = 100;
var energyTrack = 75;
var distTrack = 0;
var beginningDist = 0;
var toggleExplosion = true;
var starty = playerPositionY;
var startx = playerPositionX;
var playerStarted = false;
var curvedCoolApply = 0;
var curvedHeatApply = 0;
var delayAction = 0
var binarySwitch = 0;
var timeDelayCounter = 0;
var colorSwitch = "white";
var removeEnemy = 0;
var playerInvinsibility = 0;
var shootCharge = 0;
var readyToShoot = false;
var armLength = 0;
var armContact = false;
function gameUpdate() {
  function updateContents() {
      bcanv.width = canvasWidths;
      if (playerDead == false) {
        drawCircle(playerPositionX, playerPositionY, playerRotation, spaceShipColor, armLength)
      }
    //
    if (gameStarted != 2) {
      if (gameStarted == 1 && gameStarted != 3) {
        if (scroll>=blockSize*ticker) {
          ticker = ticker + 1;
        }
        if ((scroll/2)>=blockSize*starTicker) {
          starTicker = starTicker + 1;
        }
        scroll = scroll + playerVelocityX;
        createFireParticles(255, 0, 0, 255, 140, 0, playerPositionX, playerPositionY, 3.5, 1, playerRotation);
      }
    }
    //
    // \/\/\/ creates blinking effect
      if (binarySwitch == 0) {
        timeDelayCounter++
        if (timeDelayCounter >= 20) {
          colorSwitch = "#4c4c4c"//#72ff7e just in case color
          binarySwitch = 1;
          timeDelayCounter = 0;
        }
      }
      else if (binarySwitch == 1){
        timeDelayCounter++
        if (timeDelayCounter >= 20) {
          colorSwitch = "white"
          binarySwitch = 0;
          timeDelayCounter = 0;
        }
      }
      // /\/\/\
      var shouldRefresh = true
      var enemiesOnScreen = -1;
      //double nested Ifs because compiler was freaking out for some reason with && argument
      if (enemiesHold[0] != null) {
        if (enemiesHold[0].enemyID < ticker-2) {
          enemiesHold.shift();
        }
      }
      ecanv.width = canvasWidths;
      enemies.translate(0-scroll, 0);
    if (ticker > test.length-200) {
      generateChunck(test.length, biome);
      calculateLandingSpots();
    }
    for(i=0+ticker-2; i<=blockAmount+ticker;++i) {
        if (landPositions[i] != 0) {
          createLineBlock(lineBase - test[i-1], lineBase - test[i], colorSwitch)
        }
        else if(landPositions[i] == 0) {
          createLineBlock(lineBase - test[i-1], lineBase - test[i], "white")
        }

        if (enemyPositions[i] == 1 && landPositions[i] == 0 || enemyPositions[i] == 2 && landPositions[i] == 0 || enemyPositions[i] == 3) {
          // if (shouldRefresh == true) {
          //   ecanv.width = canvasWidths;
          //
          //   shouldRefresh = false;
          // }
          enemiesOnScreen++;
          drawEnemy(i * blockSize, lineBase - test[i], i, enemiesOnScreen, enemyPositions[i]);
        }
      }
    for(i=0+starTicker-1; i<=blockAmount+starTicker;++i) {
      drawStars(i * blockSize, starPos[i]);
    }
    //{'xPos':0, 'yPos':0, 'xVel':0, 'yVel':0, 'lifeSpan':350}
    projCanv.width = canvasWidths;
    for (var q = 0; q < bullets.length; q++) {
      if (bullets[q] != null && bullets[q].id == "enemy") {
        bullets[q].yVel = bullets[q].yVel + 0.01;//effects of gravity
        bullets[q].xPos = bullets[q].xPos + bullets[q].xVel;
        bullets[q].yPos = bullets[q].yPos + bullets[q].yVel;

        if (objAboveGround(bullets[q].xPos-scroll, 0, ticker, scroll, 1) <= bullets[q].yPos+7 && bullets[q].lifeSpan <= 440) {
          ////// Tediouse conversions to 360* scale. Best method I could figure for getting realistic bounces.
          //It finds the perpendicular of the terrain unit's ground and mirrors the entrt angle over the perpendiclular and then redistributes
          //the velocities of x and y according to the ratio. Planning to recylce the function that gave velocity based on gun rotation.
          //very proud I got this to work
          // var zone = objAboveGround(bullets[q].xPos-scroll, 0, ticker, scroll, 2)
          var zone = Math.trunc(bullets[q].xPos/blockSize);
          var zoneStart = test[zone];
          var zoneEnd = test[zone+1];
          var collectedPower = Math.abs(bullets[q].yVel) + Math.abs(bullets[q].xVel);
          var ratioOfAngle = (Math.atan((zoneStart-zoneEnd)/(blockSize)))*180/Math.PI;
          if (ratioOfAngle>=0) {
            var bottomOfAngle = ratioOfAngle;
            var topOfAngle = bottomOfAngle + 180;
          }
          else {
            var bottomOfAngle = 360+ratioOfAngle;
            var topOfAngle = bottomOfAngle-180;
          }
          if (bullets[q].yVel>=0) {
            var falling = true;
            var ballTrajectory = (Math.atan(bullets[q].xVel/bullets[q].yVel))*180/Math.PI;
            if (ballTrajectory>=0) {
              var ballAngle = 180-ballTrajectory;
            }
            else {
              var ballAngle = 180+Math.abs(ballTrajectory)
            }
            // x=o y=a
          }
          else {
            var falling = false;
            var ballTrajectory = (Math.atan(-bullets[q].yVel/bullets[q].xVel))*180/Math.PI;
            if (ballTrajectory>=0) {
              var ballAngle = 90-ballTrajectory;
            }
            else {
              var ballAngle = 270 + Math.abs(ballTrajectory);
            }
            // y=o x=a
          }
          /////////
          var perpendicularAngle = (bottomOfAngle+topOfAngle)/2;
          if (ballAngle>= perpendicularAngle) {
            var newExitAngle = perpendicularAngle-(ballAngle-perpendicularAngle);
          }
          else {
            var newExitAngle = perpendicularAngle+(perpendicularAngle-ballAngle);
          }
          //calcBulletVelocety(gunRot, 6, 'x')
          var rotated360DegScaleBy90 = newExitAngle + 90;
          if (rotated360DegScaleBy90>360) {
            rotated360DegScaleBy90-=360
          }
          var finalAngle = (rotated360DegScaleBy90/360)*2;//Converts to the arc() 0-2PI scale that my function used
          bullets[q].yPos = bullets[q].yPos-1;
          bullets[q].xVel = -calcBulletVelocety(finalAngle, collectedPower, 'x');
          bullets[q].yVel = calcBulletVelocety(finalAngle, collectedPower, 'y');
        }
        if (bullets[q].yPos > playerPositionY-25 && bullets[q].yPos < playerPositionY+26 &&
           (bullets[q].xPos-scroll) > playerPositionX-20 && (bullets[q].xPos-scroll) < playerPositionX+20 &&
            playerInvinsibility <=0 && playerStarted == true) {
          healthTrack -= 50;
          spaceShipColorAnimation(255, 0, 0);
          createParticles(bullets[q].xPos, bullets[q].yPos, "yellow", 4, 150);
          playerInvinsibility = 17;
          bullets[q].lifeSpan = 0;
        }
        bullets[q].positionHistory.push({'x':bullets[q].xPos, 'y':bullets[q].yPos});
        if (bullets[q].positionHistory.length>40) {
          bullets[q].positionHistory.splice(0, 1);
        }

        for (var d = 0; d < bullets[q].positionHistory.length; d++) {
          var sizeMult = d/bullets[q].positionHistory.length;
          projectile.beginPath();
          projectile.moveTo(bullets[q].positionHistory[d].x-scroll, bullets[q].positionHistory[d].y);
          projectile.arc(bullets[q].positionHistory[d].x-scroll, bullets[q].positionHistory[d].y, 9*sizeMult, 0, 2*Math.PI);
          projectile.fillStyle = `rgba(255, ${255*sizeMult}, 0, ${sizeMult})`;
          projectile.closePath();
          projectile.fill();
        }


        bullets[q].lifeSpan -= 1;
        if (bullets[q].lifeSpan<=0) {
          bullets.splice(q, 1);
        }

      }
      if (bullets[q] != null && bullets[q].id == "player") {

        createParticles(bullets[q].xPos, bullets[q].yPos, "white", 0.1, 1, 20);

        bullets[q].yVel = bullets[q].yVel + 0.01;//effects of gravity
        bullets[q].xPos = bullets[q].xPos + bullets[q].xVel;
        bullets[q].yPos = bullets[q].yPos + bullets[q].yVel;

      projectile.beginPath();
      projectile.moveTo(bullets[q].xPos-scroll, bullets[q].yPos);
      projectile.arc(bullets[q].xPos-scroll, bullets[q].yPos, 10, 0, 2*Math.PI);
      projectile.fillStyle = "white";
      projectile.strokeStyle = "white";
      projectile.fill();
      projectile.stroke();
      projectile.closePath();

        if (objAboveGround(bullets[q].xPos-scroll, 0, ticker, scroll, 1) <= bullets[q].yPos+10) {
          createParticles(bullets[q].xPos, bullets[q].yPos, "white", 4, 150);
          bullets.splice(q, 1);
        }
      }
      if (bullets[q] != null && bullets[q].id == "homer") {
        bullets[q].lifeSpan -= 1;
        // bullets[q].yVel = bullets[q].yVel + 0.01;//effects of gravity

        bullets[q].xPos += bullets[q].xVel;
        bullets[q].yPos += bullets[q].yVel

        var changeVel = (vel, speed, polarity) => {return vel + (speed*polarity)};

        bullets[q].xVel = ((scroll+playerPositionX)>bullets[q].xPos) ? changeVel(bullets[q].xVel, 0.09, 1) : changeVel(bullets[q].xVel, 0.09, -1);
        bullets[q].yVel = (playerPositionY>(bullets[q].yPos)) ? changeVel(bullets[q].yVel, 0.09, 1) : changeVel(bullets[q].yVel, 0.09, -1);

        if (bullets[q].xVel > 4) bullets[q].xVel = 4;
        if (bullets[q].xVel < -4) bullets[q].xVel = -4;
        if (bullets[q].yVel > 4) bullets[q].yVel = 4;
        if (bullets[q].yVel < -4) bullets[q].yVel = -4;

        if (bullets[q].lifeSpan>10) {
          bullets[q].positionHistory.push({'x':bullets[q].xPos, 'y':bullets[q].yPos});
          if (bullets[q].positionHistory.length>5) bullets[q].positionHistory.splice(0, 1);
        }
        if (bullets[q].lifeSpan<=10 && bullets[q].lifeSpan%2 == 0) bullets[q].positionHistory.splice(0, 1);



        for (var d = 0; d < bullets[q].positionHistory.length; d++) {

          if (bullets[q].lifeSpan>10) {
            var sizeMult = d/bullets[q].positionHistory.length;
            sizeMult = 1-sizeMult + 0.1;
          }
          else {
            var sizeMult = d/5;
            sizeMult = sizeMult+0.1;
          }
          projectile.beginPath();
          projectile.arc(bullets[q].positionHistory[d].x-scroll, bullets[q].positionHistory[d].y, 5*(sizeMult), 0, 2*Math.PI);
          projectile.fillStyle = "green";
          projectile.fill();
          projectile.closePath();
        }

        if (bullets[q].yPos > playerPositionY-25 && bullets[q].yPos < playerPositionY+26 &&
           (bullets[q].xPos-scroll) > playerPositionX-20 && (bullets[q].xPos-scroll) < playerPositionX+20 &&
            playerInvinsibility <=0 && playerStarted == true) {
          healthTrack -= 5;
          spaceShipColorAnimation(255, 0, 0);
          playerInvinsibility = 17;
          createParticles(bullets[q].xPos, bullets[q].yPos, "green", 4, 60);
          bullets[q].lifeSpan = 0;
        }

        if (objAboveGround(bullets[q].xPos-scroll, 0, ticker, scroll, 1) <= bullets[q].yPos+6) {
          bullets[q].lifeSpan = 0;
          createParticles(bullets[q].xPos, bullets[q].yPos, "green", 4, 60);
        }
        if (bullets[q].lifeSpan<=0){
          createParticles(bullets[q].xPos, bullets[q].yPos, "green", 4, 5)
           bullets.splice(q, 1);
         }
      }
    }
    playerInvinsibility--;
    //////
    /////
    //general Particle Managment
    pcanv.width = canvasWidths;
    fcanv.width = canvasWidths;
    for (var q = 0; q < particleIndex.length; q++) {
      var lifeSpent = particleIndex[q].lifeLived/particleIndex[q].lifeSpan;
      particleIndex[q].xPos += particleIndex[q].xVel;
      particleIndex[q].yPos += particleIndex[q].yVel;
      particleIndex[q].lifeLived += Math.abs(particleIndex[q].xVel) + Math.abs(particleIndex[q].yVel);
      if (particleIndex[q].id == "general") {
        particles.beginPath();
        particles.rect(particleIndex[q].xPos-scroll, particleIndex[q].yPos, 8*lifeSpent, 8*lifeSpent);
        particles.globalAlpha = 1-lifeSpent;
        particles.fillStyle = particleIndex[q].color;
        particles.fill();
        particles.closePath();
        if (objAboveGround(particleIndex[q].xPos-scroll, 0, ticker, scroll, 1) <= particleIndex[q].yPos) {
          particleIndex[q].yVel *= -1;
          particleIndex[q].xVel *= -1;
        }
      }
      else if (particleIndex[q].id == "exhaust") {
        particleIndex[q].yVel += 0.02;

        fire.beginPath();
        fire.rect(particleIndex[q].xPos, particleIndex[q].yPos, 5*(lifeSpent+0.6), 5*(lifeSpent+0.6));
        fire.globalAlpha = 1.25-lifeSpent;
        fire.fillStyle = `rgb(${particleIndex[q].red-(particleIndex[q].redChange*lifeSpent)},
                              ${particleIndex[q].green-(particleIndex[q].greenChange*lifeSpent)},
                              ${particleIndex[q].blue-(particleIndex[q].blueChange*lifeSpent)})`;
        fire.fill();
        fire.closePath();
        if (objAboveGround(particleIndex[q].xPos, 0, ticker, scroll, 1) <= particleIndex[q].yPos+6) {
          particleIndex[q].yVel *= -1;
          particleIndex[q].xVel *= -1.7;
        }
      }


      if (particleIndex[q].lifeLived >= particleIndex[q].lifeSpan) {
        particleIndex.splice(q, 1);
      }
    }
    if (spaceShipColorValues.animStarted == true) {
      if (spaceShipColorValues.returnToNormal == false) {
        spaceShipColorValues.animProgress += 0.1;
        if (spaceShipColorValues.animProgress >= 1) {
          spaceShipColorValues.returnToNormal = true
        }
      }
      if (spaceShipColorValues.returnToNormal == true) {
        spaceShipColorValues.animProgress -= 0.025;
        if (spaceShipColorValues.animProgress <= 0) {
          spaceShipColorValues.animProgress = 0;
          spaceShipColorValues.animStarted = false;
          spaceShipColorValues.returnToNormal = false;
        }
      }
      spaceShipColor = `rgb(${255-(spaceShipColorValues.differenceRed*spaceShipColorValues.animProgress)},
                        ${255-(spaceShipColorValues.differenceGreen*spaceShipColorValues.animProgress)},
                        ${255-(spaceShipColorValues.differenceBlue*spaceShipColorValues.animProgress)})`;
    }
    //Window Expansion
    windowWidth = window.innerWidth;
    if (windowWidth >= 1000) {
      blockAmount = Math.ceil(windowWidth/blockSize)
      canvasWidths = (blockSize*blockAmount) - (blockSize*3);
      screenOfGame.style.width = `${windowWidth}px`
    }
    if (playerStarted == true) {
      delayAction++
      var groundHeight = objAboveGround(playerPositionX, playerPositionY, ticker, scroll, 1);
      var zoneCount = objAboveGround(playerPositionX, playerPositionY, ticker, scroll, 2);
      var zoneCountLeft = objAboveGround(playerPositionX, playerPositionY, ticker, scroll, 3);
      var zoneCountRight = objAboveGround(playerPositionX, playerPositionY, ticker, scroll, 4);
      playerVelocityY = playerVelocityY + gravityMult;
      if (playerPositionX>=canv.width*0.75) {
        playerPositionX = playerPositionX - playerVelocityX;
        scroll = scroll + playerVelocityX;
      }
      if (scroll>=blockSize*ticker) {
        ticker = ticker + 1;
      }
      if ((scroll/2)>=blockSize*starTicker) {
        starTicker = starTicker + 1;
      }
      // shoot \\
      if (shootInput == true && energyTrack > 15) {
        readyToShoot = true;
        if (shootCharge<5) {
          shootCharge += 0.03
        }
      }
      else if (readyToShoot == true && shootInput == false) {
        energyTrack -= 15;
        bulletInstantiate(playerVelocityX, playerPositionX+scroll, playerPositionY, 1, shootCharge);
        shootCharge = 0;
        readyToShoot = false;
      }
      if (useArm == true) {
        if (armContact == false) {
          var doneRetracting = armLength<70 ? +0.1 : 0;
          armLength += doneRetracting;
        }
      }
      else {
        var doneRetracting = armLength>0 ? -0.1 : 0;
        armLength += doneRetracting;
      }
      ///// TRUE INPUT
    if (input == true && fuelTrack > 0 && tempTrack < 200 && delayAction>3) {
      if (curvedHeatApply < 0) {
        curvedHeatApply = curvedHeatApply + 0.003;
      }
      fuelTrack = fuelTrack - 1;
      curvedCoolApply = 0;
      curvedHeatApply = curvedHeatApply + 0.00006;
      tempTrack = tempTrack + curvedHeatApply;
      fireParticlesY = (0.007*yMult);
      fireParticlesX = (0.007*xMult);
      if (useBoost == false) {
        playerVelocityY = playerVelocityY - (0.0095*yMult);
        playerVelocityX = playerVelocityX - (0.0095*xMult);
        createFireParticles(255, 0, 0, 255, 140, 0, playerPositionX, playerPositionY, (0.0095*xMult)*2, (0.0095*yMult)*2, playerRotation);
      }
      else if (useBoost == true) {
        playerVelocityY = playerVelocityY - (0.023*yMult);
        playerVelocityX = playerVelocityX - (0.023*xMult);
        createFireParticles(255, 255, 0, 255, 140, 0, playerPositionX, playerPositionY, (0.023*xMult)*2, (0.023*yMult)*2, playerRotation);

      }

    }
    //// FALSE INPUT
    if (input == false) {
      if (contactMade == false && tempTrack > 50) {
        if (curvedHeatApply > 0) {
          curvedHeatApply = curvedHeatApply - 0.003;
        }
        curvedCoolApply = curvedCoolApply - 0.00003;
        tempTrack = tempTrack + curvedCoolApply;
      }
      fade = 0;
    }
    var velHolder = 0;
    if (playerPositionY >= groundHeight - 30.05) {
      velHolder = playerVelocityY;
      playerVelocityY = -playerVelocityY * 0.25
      playerPositionY = groundHeight - 30.05;
    }
///
/////Contact Conditions
    if (playerPositionY >= groundHeight - 30.1 && playerPositionY <= groundHeight - 30.001) {
      if (playerVelocityX > 0) {
        playerVelocityX = playerVelocityX - 0.035;
      }
      else if (playerVelocityX < 0) {
        playerVelocityX = playerVelocityX + 0.035;
      }
      else {
        playerVelocityX = 0;
      }
      contactMade = true;
      ///Landing Conditions
      if (contactMade == true && playerRotation > 3 ||
          contactMade == true && playerRotation < -3 ||
          contactMade == true && velHolder > 1 ||
          contactMade == true && landPositions[zoneCount+1] == 0) {
        playerDead = true;
        fuelTrack = 0;
        tempTrack = 0;
        healthTrack = 0;
      }
      else if (contactMade == true && velHolder > 0.32) {
        healthTrack = healthTrack - Math.floor((10*velHolder)*4);
        spaceShipColorAnimation(255, 0, 0);
      }

    }
    else if(playerPositionY <= groundHeight - 31) {
      contactMade = false;
    }

    if (contactMade == true) {
      playerVelocityX = 0;
      if (playerVelocityY > 0) {
        playerVelocityY = 0;
      }
    }
///
if (healthTrack<=0) {
  playerDead = true;
  fuelTrack = 0;
  tempTrack = 0;
  healthTrack = 0
  drawStats(fuelTrack, tempHolder, distTrack, healthTrack, energyTrack, playerRotation);
}
    //// Rot Inputs
    if (inputRotLeft == true && contactMade == false) {
      if (playerRotation > -90) {
        playerRotation--
      }
    }
    if (inputRotRight == true && contactMade == false) {
      if (playerRotation < 90) {
        playerRotation++
      }
    }
    if (contactMade == true) {
      if (tempTrack > 50) {
        curvedCoolApply = curvedCoolApply - 0.00015;
        tempTrack = tempTrack + curvedCoolApply;
      }
      else {
        curvedCoolApply = 0;
        tempTrack = tempTrack - 0.0003
      }
    }
    // Math that moves the player at different x and y velocities that makes sense with the rotation
    if (playerRotation > 0) {
      if (playerRotation < 45) {
        yMult = 1 - playerRotation/90
        xMult = -(playerRotation/90)
      }
      // more extreme rotation
      else if (playerRotation > 45) {
        yMult = 1 - playerRotation/90
        xMult = -(playerRotation/90)
      }
    }
    else if (playerRotation < 0) {
      if (playerRotation >= -45) {
        yMult = 1 + playerRotation/90
        xMult = (1 + playerRotation/90)
      }
      //more extreme rotation
      else if (playerRotation < -45) {
        yMult = 1 + playerRotation/90
        xMult = -(playerRotation/90)
      }
    }
    else {
      yMult = 1
      xMult = 0
    }
    // Air resistence
    if (playerVelocityX > 0) {
      playerVelocityX = playerVelocityX - 0.00003
    }
    else if (playerVelocityX < 0) {
      playerVelocityX = playerVelocityX + 0.00003
    }
    if (beginningDist < canv.width*0.75) {
      if (playerVelocityX > 0.01 && contactMade == false) {
        beginningDist = beginningDist + playerVelocityX;
        distTrack = Math.floor(beginningDist/10);
      }
    }
    else {
      if (playerVelocityX > 0.01 && contactMade == false) {
        beginningDist = canv.width*0.75 + 1;
        distTrack = Math.floor((beginningDist + scroll - scrollOffsetTitleScreen)/10);
      }
    }
    //Constraints on going backwords
    if (playerPositionX < 20 && playerVelocityX < 0) {
      playerVelocityX = playerVelocityX/10
    }
    // makes stats see through when player goes near
    if (playerPositionX < 370 && playerPositionY < 165) {
      statLeft.style.opacity = 0.6;
    }
    else {
      statLeft.style.opacity = 1;
    }
    drawTragectory(playerVelocityX, playerVelocityY, gravityMult);
    distTrack = Math.ceil(distTrack*100)/100
    var tempHolder = Math.ceil(tempTrack*100)/100
    drawStats(fuelTrack, tempHolder, distTrack, healthTrack, energyTrack, playerRotation);

    if (playerDead == true) {
      bcanv.width = canvasWidths;
      gameOptions.style.opacity = "1";
      gameOptions.style.color = "red";
      gameOptions.style.zIndex = 700;
      startButtonText.innerHTML = "Title Screen"
      titleInformation.style.color = "red";
      titleInformation.innerHTML = "Game Over";
      if (toggleExplosion == true) {
        recordOfScores.push({'rank':2, 'distance':`${distTrack}m`, 'username':currentUser});
        createParticles(playerPositionX+scroll, playerPositionY, "white", 4, 350);
        toggleExplosion = false;
      }
      // startButton.style.zIndex = 1000;
      // startButton.classList.replace("startButton", "gameOverButton")
      // startButton.innerHTML = "Play Again";
      playerStarted = false;
      playerVelocityX = 0;
    }
    playerPositionY = playerPositionY + playerVelocityY;
    playerPositionX = playerPositionX + playerVelocityX;
    }
    // energyUpInstantiate(400+scroll, 400, 5);
  }
  var masterUpdate = setInterval(updateContents, 1000/60);
}
startButton.addEventListener("click", function() {
  currentUser = userInput.value;
  playerStarted = true;
  gameStarted = 2;
  drawTitleScreen();
  scrollOffsetTitleScreen = scroll;
  createParticles(playerPositionX+scroll, playerPositionY, "#e2320b", 4)
  toggleExplosion = true;
  groundHeight = startx;
  playerPositionY = starty
  if (playerDead == true) {
    window.location.reload(true);
  }
});
leaderBoard.addEventListener("click", function(){
  leaderBoardDisplay.style.opacity = 1;
  leaderBoardDisplay.style.zIndex = 1000;
  titleScreen.style.zIndex = -700;
  titleScreen.style.opacity = 0;
});
backButton.addEventListener("click", function(){
  leaderBoardDisplay.style.opacity = 0;
  leaderBoardDisplay.style.zIndex = -10000;
  titleScreen.style.zIndex = 700;
  titleScreen.style.opacity = 1;
});
document.addEventListener("DOMContentLoaded", function() {
  if (gameStarted == 5) {
    gameStarted = 1;
    for (var m = 0; m < manualCanvasArr.length; m++) {
      manualCanvasArr[m].width = canvasWidths;
    }
    // fireMove("yellow")
    drawCircle(playerPositionX, playerPositionY, playerRotation, spaceShipColor);
    gameUpdate();
  }
});
function groupOfGameOverEvents() {
}
var inputRotRight
var inputRotLeft
var shootInput;
var useBoost = false;
var useArm = false;
kd.W.down(function () {
input = true;
});
kd.W.up(function () {
 input = false;
});
kd.A.down(function () {
  inputRotLeft = true;
});
kd.A.up(function () {
 inputRotLeft = false;
});
kd.D.down(function () {
  inputRotRight = true;
});
kd.D.up(function () {
  inputRotRight = false;
});
kd.SPACE.down(function () {
  shootInput = true;
});
kd.SPACE.up(function () {
  shootInput = false;
});
kd.SHIFT.down(function () {
  useBoost = true;
});
kd.SHIFT.up(function () {
  useBoost = false;
});
//will not use f for this in the future
kd.F.down(function () {
  useArm = true;
});
kd.F.up(function () {
  useArm = false;
});
// This update loop is the heartbeat of Keydrown
kd.run(function () {
  kd.tick();
});
  </script>
</html>
